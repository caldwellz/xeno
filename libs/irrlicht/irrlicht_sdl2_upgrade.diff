Index: Android.mk
===================================================================
--- Android.mk	(revision 0)
+++ Android.mk	(working copy)
@@ -0,0 +1,145 @@
+LOCAL_PATH := $(call my-dir)
+
+SDL_PATH := ../SDL
+
+###########################
+#
+# Irrlicht shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := Irrlicht
+
+LOCAL_CFLAGS := -D_IRR_COMPILE_WITH_SDL2_DEVICE_ -DNO_IRR_COMPILE_WITH_OPENGL_
+
+LOCAL_CFLAGS += -Wall -pipe -fno-exceptions -fno-rtti -fstrict-aliasing -fexpensive-optimizations -O3
+
+SRC_PATH := $(LOCAL_PATH)/source/Irrlicht
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include $(LOCAL_PATH)/$(SDL_PATH)/include $(SRC_PATH)
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES :=  	$(subst $(LOCAL_PATH)/,, \
+					$(wildcard $(SRC_PATH)/Android/*.cpp) \
+					$(SRC_PATH)/aesGladman/aescrypt.cpp \
+					$(SRC_PATH)/aesGladman/aeskey.cpp \
+					$(SRC_PATH)/aesGladman/aestab.cpp \
+					$(SRC_PATH)/aesGladman/fileenc.cpp \
+					$(SRC_PATH)/aesGladman/hmac.cpp \
+					$(SRC_PATH)/aesGladman/prng.cpp \
+					$(SRC_PATH)/aesGladman/pwd2key.cpp \
+					$(SRC_PATH)/aesGladman/sha1.cpp \
+					$(SRC_PATH)/aesGladman/sha2.cpp \
+					$(wildcard $(SRC_PATH)/*.cpp) \
+					$(SRC_PATH)/bzip2/blocksort.c \
+					$(SRC_PATH)/bzip2/bzcompress.c \
+					$(SRC_PATH)/bzip2/bzlib.c \
+					$(SRC_PATH)/bzip2/crctable.c \
+					$(SRC_PATH)/bzip2/decompress.c \
+					$(SRC_PATH)/bzip2/huffman.c \
+					$(SRC_PATH)/bzip2/randtable.c \
+					$(SRC_PATH)/jpeglib/jaricom.c \
+					$(SRC_PATH)/jpeglib/jcapimin.c \
+					$(SRC_PATH)/jpeglib/jcapistd.c \
+					$(SRC_PATH)/jpeglib/jcarith.c \
+					$(SRC_PATH)/jpeglib/jccoefct.c \
+					$(SRC_PATH)/jpeglib/jccolor.c \
+					$(SRC_PATH)/jpeglib/jcdctmgr.c \
+					$(SRC_PATH)/jpeglib/jchuff.c \
+					$(SRC_PATH)/jpeglib/jcinit.c \
+					$(SRC_PATH)/jpeglib/jcmainct.c \
+					$(SRC_PATH)/jpeglib/jcmarker.c \
+					$(SRC_PATH)/jpeglib/jcmaster.c \
+					$(SRC_PATH)/jpeglib/jcomapi.c \
+					$(SRC_PATH)/jpeglib/jcparam.c \
+					$(SRC_PATH)/jpeglib/jcprepct.c \
+					$(SRC_PATH)/jpeglib/jcsample.c \
+					$(SRC_PATH)/jpeglib/jctrans.c \
+					$(SRC_PATH)/jpeglib/jdapimin.c \
+					$(SRC_PATH)/jpeglib/jdapistd.c \
+					$(SRC_PATH)/jpeglib/jdarith.c \
+					$(SRC_PATH)/jpeglib/jdatadst.c \
+					$(SRC_PATH)/jpeglib/jdatasrc.c \
+					$(SRC_PATH)/jpeglib/jdcoefct.c \
+					$(SRC_PATH)/jpeglib/jdcolor.c \
+					$(SRC_PATH)/jpeglib/jddctmgr.c \
+					$(SRC_PATH)/jpeglib/jdhuff.c \
+					$(SRC_PATH)/jpeglib/jdinput.c \
+					$(SRC_PATH)/jpeglib/jdmainct.c \
+					$(SRC_PATH)/jpeglib/jdmarker.c \
+					$(SRC_PATH)/jpeglib/jdmaster.c \
+					$(SRC_PATH)/jpeglib/jdmerge.c \
+					$(SRC_PATH)/jpeglib/jdpostct.c \
+					$(SRC_PATH)/jpeglib/jdsample.c \
+					$(SRC_PATH)/jpeglib/jdtrans.c \
+					$(SRC_PATH)/jpeglib/jerror.c \
+					$(SRC_PATH)/jpeglib/jfdctflt.c \
+					$(SRC_PATH)/jpeglib/jfdctfst.c \
+					$(SRC_PATH)/jpeglib/jfdctint.c \
+					$(SRC_PATH)/jpeglib/jidctflt.c \
+					$(SRC_PATH)/jpeglib/jidctfst.c \
+					$(SRC_PATH)/jpeglib/jidctint.c \
+					$(SRC_PATH)/jpeglib/jmemmgr.c \
+					$(SRC_PATH)/jpeglib/jmemnobs.c \
+					$(SRC_PATH)/jpeglib/jquant1.c \
+					$(SRC_PATH)/jpeglib/jquant2.c \
+					$(SRC_PATH)/jpeglib/jutils.c \
+					$(SRC_PATH)/libpng/png.c \
+					$(SRC_PATH)/libpng/pngerror.c \
+					$(SRC_PATH)/libpng/pngget.c \
+					$(SRC_PATH)/libpng/pngmem.c \
+					$(SRC_PATH)/libpng/pngpread.c \
+					$(SRC_PATH)/libpng/pngread.c \
+					$(SRC_PATH)/libpng/pngrio.c \
+					$(SRC_PATH)/libpng/pngrtran.c \
+					$(SRC_PATH)/libpng/pngrutil.c \
+					$(SRC_PATH)/libpng/pngset.c \
+					$(SRC_PATH)/libpng/pngtrans.c \
+					$(SRC_PATH)/libpng/pngwio.c \
+					$(SRC_PATH)/libpng/pngwrite.c \
+					$(SRC_PATH)/libpng/pngwtran.c \
+					$(SRC_PATH)/libpng/pngwutil.c \
+					$(SRC_PATH)/lzma/LzmaDec.c \
+					$(SRC_PATH)/zlib/adler32.c \
+					$(SRC_PATH)/zlib/crc32.c \
+					$(SRC_PATH)/zlib/gzclose.c \
+					$(SRC_PATH)/zlib/gzread.c \
+					$(SRC_PATH)/zlib/infback.c \
+					$(SRC_PATH)/zlib/inflate.c \
+					$(SRC_PATH)/zlib/trees.c \
+					$(SRC_PATH)/zlib/zutil.c \
+					$(SRC_PATH)/zlib/compress.c \
+					$(SRC_PATH)/zlib/deflate.c \
+					$(SRC_PATH)/zlib/gzlib.c \
+					$(SRC_PATH)/zlib/gzwrite.c \
+					$(SRC_PATH)/zlib/inffast.c \
+					$(SRC_PATH)/zlib/inftrees.c \
+					$(SRC_PATH)/zlib/uncompr.c)
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lEGL -llog -lGLESv1_CM -lGLESv2 -lz -landroid
+
+LOCAL_STATIC_LIBRARIES := android_native_app_glue
+
+include $(BUILD_SHARED_LIBRARY)
+
+###########################
+#
+# Irrlicht static library
+#
+###########################
+
+#LOCAL_MODULE := Irrlicht_static
+
+#LOCAL_MODULE_FILENAME := Irrlicht
+
+#LOCAL_LDLIBS := 
+#LOCAL_EXPORT_LDLIBS := -lEGL -llog -lGLESv1_CM -lGLESv2 -lz -landroid -lSDL2
+
+#include $(BUILD_STATIC_LIBRARY)
+
+$(call import-module,android/native_app_glue)
Index: changes.txt
===================================================================
--- changes.txt	(revision 4940)
+++ changes.txt	(working copy)
@@ -3,6 +3,7 @@
 
 - Merge material changes for COGLES1MaterialRenderer_LIGHTMAP and COpenGLMaterialRenderer_TRANSPARENT_ALPHA_CHANNEL which had been done in OGL in trunk (r2740) to ensure materials look the same on all platforms.
 - Added support for PVR textures. Loader offer support for compressed DXT1-5, PVRTC/PVRTC-II, ETC1/ETC2 texture formats.
+- Added SDL2 device.  Works on Linux with GL & BurningsVideo and Android with GLES1&2.
 
 --------------------------
 Changes in 1.9 (not yet released)
Index: include/EDeviceTypes.h
===================================================================
--- include/EDeviceTypes.h	(revision 4940)
+++ include/EDeviceTypes.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __E_DEVICE_TYPES_H_INCLUDED__
 #define __E_DEVICE_TYPES_H_INCLUDED__
@@ -28,7 +32,7 @@
 		//! A device native to Mac OSX
 		/** This device uses Apple's Cocoa API and works in Mac OSX 10.2 and above. */
 		EIDT_OSX,
-        
+
         //! A device native to the IPhone/IPod touch
 		/** This device should be used with the OpenGL-ES driver. */
 		EIDT_IPHONE,
@@ -56,12 +60,17 @@
 		will be tried. This ensures that Irrlicht will run even if your platform is unsupported,
 		although it may not be able to render anything. */
 		EIDT_BEST,
-		
+
 		//! A device for Android platforms
 		/** Best used with embedded devices and mobile systems.
 		Does not need X11 or other graphical subsystems.
 		May support hw-acceleration via OpenGL-ES */
-		EIDT_ANDROID,		
+		EIDT_ANDROID,
+
+		//! A device which uses Simple DirectMedia Layer
+		/** The SDL2 device works under all platforms supported by SDL2 but first must be compiled
+		in by defining the IRR_USE_SDL2_DEVICE macro in IrrCompileConfig.h */
+		EIDT_SDL2
 	};
 
 } // end namespace irr
Index: include/IrrCompileConfig.h
===================================================================
--- include/IrrCompileConfig.h	(revision 4940)
+++ include/IrrCompileConfig.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __IRR_COMPILE_CONFIG_H_INCLUDED__
 #define __IRR_COMPILE_CONFIG_H_INCLUDED__
@@ -51,6 +55,12 @@
 #undef _IRR_COMPILE_WITH_SDL_DEVICE_
 #endif
 
+//! Uncomment this line to compile with the SDL2 device
+//#define _IRR_COMPILE_WITH_SDL2_DEVICE_
+#ifdef NO_IRR_COMPILE_WITH_SDL2_DEVICE_
+#undef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#endif
+
 //! Comment this line to compile without the fallback console device.
 #define _IRR_COMPILE_WITH_CONSOLE_DEVICE_
 #ifdef NO_IRR_COMPILE_WITH_CONSOLE_DEVICE_
@@ -124,10 +134,10 @@
 #endif
 #endif
 
-#if !defined(_IRR_WINDOWS_API_) && !defined(_IRR_OSX_PLATFORM_) && !defined(_IRR_ANDROID_PLATFORM_)
-#ifndef _IRR_SOLARIS_PLATFORM_
-#define _IRR_LINUX_PLATFORM_
-#endif
+#if !defined(_IRR_WINDOWS_API_) && !defined(_IRR_OSX_PLATFORM_) && !defined(_IRR_ANDROID_PLATFORM_) && !defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+	#ifndef _IRR_SOLARIS_PLATFORM_
+	#define _IRR_LINUX_PLATFORM_
+	#endif // _IRR_SOLARIS_PLATFORM_
 #define _IRR_POSIX_API_
 #define _IRR_COMPILE_WITH_X11_DEVICE_
 #endif
Index: source/Irrlicht/CEGLManager.cpp
===================================================================
--- source/Irrlicht/CEGLManager.cpp	(revision 4940)
+++ source/Irrlicht/CEGLManager.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2013 Patryk Nadrowski
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "CEGLManager.h"
 
@@ -7,7 +11,11 @@
 #ifdef _IRR_COMPILE_WITH_EGL_MANAGER_
 
 #include "irrString.h"
-#include "os.h"
+#include "os.h"
+
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+#include <SDL2/SDL.h>
+#endif // defined
 
 namespace irr
 {
@@ -34,6 +42,10 @@
 	// store new data
 	Params=params;
 	Data=data;
+
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    if(Params.DeviceType == EIDT_SDL2) return true;
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
 
 	if (EglWindow != 0 && EglDisplay != EGL_NO_DISPLAY)
         return true;
@@ -72,7 +84,7 @@
         return false;
     }
 	else
-		os::Printer::log("EGL version", core::stringc(MajorVersion+(MinorVersion*0.1f)).c_str());
+		os::Printer::log("EGL version", core::stringc(MajorVersion+(MinorVersion*0.1f)).c_str());
 
     return true;
 }
@@ -79,6 +91,9 @@
 
 void CEGLManager::terminate()
 {
+    MajorVersion = 0;
+    MinorVersion = 0;
+
     if (EglWindow == 0 && EglDisplay == EGL_NO_DISPLAY)
         return;
 
@@ -98,13 +113,14 @@
         Data.OpenGLWin32.HDc = 0;
     }
 #endif
-
-    MajorVersion = 0;
-    MinorVersion = 0;
 }
 
 bool CEGLManager::generateSurface()
-{
+{
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    if(Params.DeviceType == EIDT_SDL2) return true;
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
     if (EglDisplay == EGL_NO_DISPLAY)
         return false;
 
@@ -260,7 +276,7 @@
 #endif
 
     if (Params.Vsync)
-		eglSwapInterval(EglDisplay, 1);
+		eglSwapInterval(EglDisplay, 1);
 
     return true;
 }
@@ -278,7 +294,11 @@
 }
 
 bool CEGLManager::generateContext()
-{
+{
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    if(Params.DeviceType == EIDT_SDL2) return true;
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
     if (EglDisplay == EGL_NO_DISPLAY || EglSurface == EGL_NO_SURFACE)
         return false;
 
@@ -328,12 +348,19 @@
 	// We must unbind current EGL context before destroy it.
 	eglMakeCurrent(EglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
 	eglDestroyContext(EglDisplay, EglContext);
-
     EglContext = EGL_NO_CONTEXT;
 }
 
 bool CEGLManager::activateContext(const SExposedVideoData& videoData)
-{
+{
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    if(Params.DeviceType == EIDT_SDL2)
+    {
+        Data = videoData;
+        return true;
+    }
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
 	eglMakeCurrent(EglDisplay, EglSurface, EglSurface, EglContext);
 
 	if (testEGLError())
@@ -350,8 +377,13 @@
 }
 
 bool CEGLManager::swapBuffers()
-{
-    return (eglSwapBuffers(EglDisplay, EglSurface)==EGL_TRUE);
+{
+#if !defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    return (eglSwapBuffers(EglDisplay, EglSurface) == EGL_TRUE);
+#else
+    SDL_GL_SwapWindow((SDL_Window*)Params.WindowId);
+    return true;
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
 }
 
 bool CEGLManager::testEGLError()
Index: source/Irrlicht/CEGLManager.h
===================================================================
--- source/Irrlicht/CEGLManager.h	(revision 4940)
+++ source/Irrlicht/CEGLManager.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2013 Patryk Nadrowski
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_EGL_MANAGER_H_INCLUDED__
 #define __C_EGL_MANAGER_H_INCLUDED__
@@ -7,12 +11,16 @@
 
 #include "IrrCompileConfig.h"
 
-#ifdef _IRR_COMPILE_WITH_EGL_MANAGER_
+#ifdef _IRR_COMPILE_WITH_EGL_MANAGER_
 
-#if defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include <SDL2/SDL_egl.h>
+#endif
+
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include <EGL/egl.h>
 #else
-#include <GLES/egl.h>
+#include <GLES/egl.h> // is this even needed?
 #endif
 
 #include "SIrrCreationParameters.h"
Index: source/Irrlicht/CFileSystem.cpp
===================================================================
--- source/Irrlicht/CFileSystem.cpp	(revision 4940)
+++ source/Irrlicht/CFileSystem.cpp	(working copy)
@@ -25,14 +25,14 @@
 #include "CWriteFile.h"
 #include "irrList.h"
 
-#if defined (_IRR_WINDOWS_API_)
-	#if !defined ( _WIN32_WCE )
+#if defined (_IRR_WINDOWS_API_) && !defined ( _WIN32_WCE )
 		#include <direct.h> // for _chdir
 		#include <io.h> // for _access
 		#include <tchar.h>
-	#endif
-#else
-	#if (defined(_IRR_POSIX_API_) || defined(_IRR_OSX_PLATFORM_) || defined(_IRR_ANDROID_PLATFORM_))
+#elif defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+	#include <SDL2/SDL.h>
+	#include <SDL2/SDL_rwops.h>
+#else // if (defined(_IRR_POSIX_API_) || defined(_IRR_OSX_PLATFORM_) || defined(_IRR_ANDROID_PLATFORM_))
 		#include <stdio.h>
 		#include <stdlib.h>
 		#include <string.h>
@@ -41,7 +41,6 @@
 		#include <dirent.h>
 		#include <sys/stat.h>
 		#include <unistd.h>
-	#endif
 #endif
 
 namespace irr
@@ -593,21 +592,21 @@
 	{
 		WorkingDirectory[FILESYSTEM_NATIVE] = newDirectory;
 
-#if defined(_IRR_WINDOWS_CE_PLATFORM_)
-		success = true;
-#elif defined(_MSC_VER)
-	#if defined(_IRR_WCHAR_FILESYSTEM)
-		success = (_wchdir(newDirectory.c_str()) == 0);
-	#else
-		success = (_chdir(newDirectory.c_str()) == 0);
-	#endif
-#else
-	#if defined(_IRR_WCHAR_FILESYSTEM)
-		success = (_wchdir(newDirectory.c_str()) == 0);
-	#else
-		success = (chdir(newDirectory.c_str()) == 0);
-	#endif
-#endif
+        #if defined(_IRR_WINDOWS_CE_PLATFORM_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+                success = true;
+        #elif defined(_MSC_VER)
+            #if defined(_IRR_WCHAR_FILESYSTEM)
+                success = (_wchdir(newDirectory.c_str()) == 0);
+            #else
+                success = (_chdir(newDirectory.c_str()) == 0);
+            #endif
+        #else
+            #if defined(_IRR_WCHAR_FILESYSTEM)
+                success = (_wchdir(newDirectory.c_str()) == 0);
+            #else
+                success = (chdir(newDirectory.c_str()) == 0);
+            #endif
+        #endif
 	}
 
 	return success;
@@ -962,16 +961,16 @@
 //! determines if a file exists and would be able to be opened.
 bool CFileSystem::existFile(const io::path& filename) const
 {
-	for (u32 i=0; i < FileArchives.size(); ++i)
-		if (FileArchives[i]->getFileList()->findFile(filename)!=-1)
+	for (u32 i = 0; i < FileArchives.size(); ++i)
+		if (FileArchives[i]->getFileList()->findFile(filename) != -1)
 			return true;
 
 #if defined(_IRR_WINDOWS_CE_PLATFORM_)
-#if defined(_IRR_WCHAR_FILESYSTEM)
-	HANDLE hFile = CreateFileW(filename.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
-#else
-	HANDLE hFile = CreateFileW(core::stringw(filename).c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
-#endif
+    #if defined(_IRR_WCHAR_FILESYSTEM)
+        HANDLE hFile = CreateFileW(filename.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+    #else
+        HANDLE hFile = CreateFileW(core::stringw(filename).c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+    #endif
 	if (hFile == INVALID_HANDLE_VALUE)
 		return false;
 	else
@@ -979,24 +978,38 @@
 		CloseHandle(hFile);
 		return true;
 	}
+#elif defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+    bool e = false;
+    SDL_RWops* f;
+    #if defined(_IRR_WCHAR_FILESYSTEM)
+        f = SDL_RWFromFile(filename.c_str(), L"rb");
+    #else
+        f = SDL_RWFromFile(filename.c_str(), "rb");
+    #endif
+    if(f)
+    {
+        e = true;
+        SDL_RWclose(f);
+    }
+    return e;
 #else
 	_IRR_IMPLEMENT_MANAGED_MARSHALLING_BUGFIX;
-#if defined(_MSC_VER)
-	#if defined(_IRR_WCHAR_FILESYSTEM)
-		return (_waccess(filename.c_str(), 0) != -1);
-	#else
-		return (_access(filename.c_str(), 0) != -1);
-	#endif
-#elif defined(F_OK)
-	#if defined(_IRR_WCHAR_FILESYSTEM)
-		return (_waccess(filename.c_str(), F_OK) != -1);
-	#else
-		return (access(filename.c_str(), F_OK) != -1);
-	#endif
-#else
-	return (access(filename.c_str(), 0) != -1);
+    #if defined(_MSC_VER)
+        #if defined(_IRR_WCHAR_FILESYSTEM)
+            return (_waccess(filename.c_str(), 0) != -1);
+        #else
+            return (_access(filename.c_str(), 0) != -1);
+        #endif
+    #elif defined(F_OK)
+        #if defined(_IRR_WCHAR_FILESYSTEM)
+            return (_waccess(filename.c_str(), F_OK) != -1);
+        #else
+            return (access(filename.c_str(), F_OK) != -1);
+        #endif
+    #else
+        return (access(filename.c_str(), 0) != -1);
+    #endif
 #endif
-#endif
 }
 
 
@@ -1114,4 +1127,3 @@
 
 } // end namespace irr
 } // end namespace io
-
Index: source/Irrlicht/CIrrDeviceSDL2.cpp
===================================================================
--- source/Irrlicht/CIrrDeviceSDL2.cpp	(revision 0)
+++ source/Irrlicht/CIrrDeviceSDL2.cpp	(working copy)
@@ -0,0 +1,1590 @@
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "CIrrDeviceSDL2.h"
+#include "IEventReceiver.h"
+#include "irrList.h"
+#include "os.h"
+#include "CTimer.h"
+#include "irrString.h"
+#include "Keycodes.h"
+#include "COSOperator.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "SIrrCreationParameters.h"
+#include "CEGLManager.h"
+#include "SExposedVideoData.h"
+#include "ISceneManager.h"
+#include "ICameraSceneNode.h"
+#include "CLogger.h"
+
+#ifdef _MSC_VER
+#pragma comment(lib, "SDL2.lib")
+#endif // _MSC_VER
+
+#define A_TITLE "Irrlicht on SDL2"
+
+namespace irr
+{
+	namespace video
+	{
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+		//IVideoDriver* createDirectX8Driver(const irr::SIrrlichtCreationParameters &params, io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+		//IVideoDriver* createDirectX9Driver(const irr::SIrrlichtCreationParameters &params, io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_OPENGL_
+		IVideoDriver* createOpenGLDriver(const SIrrlichtCreationParameters &params, io::IFileSystem* io, CIrrDeviceSDL2* device);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_OGLES1_
+		IVideoDriver* createOGLES1Driver(const SIrrlichtCreationParameters &params, io::IFileSystem* io, IContextManager* manager);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_OGLES2_
+		IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters &params, io::IFileSystem* io, IContextManager* manager);
+		#endif
+	} // end namespace video
+} // end namespace irr
+
+namespace irr
+{
+    //! constructor
+    CIrrDeviceSDL2::CIrrDeviceSDL2(const SIrrlichtCreationParameters &param)
+            : CIrrDeviceStub(param), MouseX(0), MouseY(0), MouseButtonStates(0),
+            Width(param.WindowSize.Width), Height(param.WindowSize.Height), Resizable(true),
+            WindowHasFocus(false), WindowMinimized(false), window((SDL_Window*)param.WindowId),
+            glContext(NULL), renderer(NULL), rendFlags(0), winFlags(SDL_WINDOW_RESIZABLE), filler()
+    {
+        #ifdef _DEBUG
+        setDebugName("CIrrDeviceSDL2");
+        #endif
+
+        #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+        SDL_SetHint(SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS, "1");
+        SDL_SetHint(SDL_HINT_IDLE_TIMER_DISABLED, "1");
+        SDL_SetHint(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, "1");
+        #endif // defined
+        SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");  // make the scaled rendering look smoother.
+        SDL_SetHint(SDL_HINT_MOUSE_RELATIVE_MODE_WARP, "1");
+
+        // Initialize SDL2... everything, because it's easier
+        if(SDL_Init(SDL_INIT_EVERYTHING) == 0)
+        {
+            // create keymap
+            createKeyMap();
+
+            // create window
+            if(createWindow())
+            {
+                SDL_VERSION(&Info.version); // initialize info structure with SDL version info
+                if(SDL_GetWindowWMInfo(window, &Info)) { // the call returns true on success
+                    // success
+                    const char *subsystem = "an unknown system!";
+                    switch(Info.subsystem) {
+                        case SDL_SYSWM_WINDOWS:
+                            subsystem = "Microsoft Windows(TM)";
+                            break;
+                        case SDL_SYSWM_X11:
+                            subsystem = "X Window System";
+                            break;
+                        #if SDL_VERSION_ATLEAST(2, 0, 3)
+                        case SDL_SYSWM_WINRT:
+                            subsystem = "WinRT";
+                            break;
+                        #endif
+                        case SDL_SYSWM_DIRECTFB:
+                            subsystem = "DirectFB";
+                            break;
+                        case SDL_SYSWM_COCOA:
+                            subsystem = "Apple OS X";
+                            break;
+                        case SDL_SYSWM_UIKIT:
+                            subsystem = "UIKit";
+                            break;
+                        #if SDL_VERSION_ATLEAST(2, 0, 2)
+                        case SDL_SYSWM_WAYLAND:
+                            subsystem = "Wayland";
+                            break;
+                        case SDL_SYSWM_MIR:
+                            subsystem = "Mir";
+                            break;
+                        #endif
+                        #if SDL_VERSION_ATLEAST(2, 0, 4)
+                        case SDL_SYSWM_ANDROID:
+                            subsystem = "Android";
+                            break;
+                        #endif
+                        default:
+                            break;
+                    }
+                    core::stringc sdlversion = "This program is running SDL version ";
+                    sdlversion += Info.version.major;
+                    sdlversion += ".";
+                    sdlversion += Info.version.minor;
+                    sdlversion += ".";
+                    sdlversion += Info.version.patch;
+                    sdlversion += " on ";
+                    sdlversion += subsystem;
+                    Operator = new COSOperator(sdlversion);
+                    os::Printer::Logger->log(sdlversion.c_str(), ELL_INFORMATION);
+                }
+                else
+                {
+                    // call failed
+                    char log[300];
+                    sprintf(log, "Couldn't get window information: %s\n", SDL_GetError());
+                    os::Printer::Logger->log(log, ELL_ERROR);
+                }
+
+                if(createRenderer())
+                {
+                    // create cursor control
+                    CursorControl = new CCursorControlSDL2(this, window);
+
+                    // create driver
+                    createDriver();
+
+                    if(VideoDriver) createGUIAndScene();
+                    else
+                    {
+                        os::Printer::Logger->log("Unable to create video driver!", ELL_ERROR);
+                        Close = true;
+                    }
+                }
+                else
+                {
+                    char log[300];
+                    sprintf(log, "Unable to create SDL renderer!  %s\n", SDL_GetError());
+                    os::Printer::Logger->log(log, ELL_ERROR);
+                    Close = true;
+                }
+            }
+            else
+            {
+                char log[300];
+                sprintf(log, "Unable to get or create SDL window!  %s\n", SDL_GetError());
+                os::Printer::Logger->log(log, ELL_ERROR);
+                Close = true;
+            }
+        }
+        else
+        {
+            char log[300];
+            sprintf(log, "Unable to initialize SDL!  %s\n", SDL_GetError());
+            os::Printer::Logger->log(log, ELL_ERROR);
+            Close = true;
+        }
+    }
+
+    //! destructor
+    CIrrDeviceSDL2::~CIrrDeviceSDL2()
+    {
+        #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+        const u32 numJoysticks = Joysticks.size();
+        for(u32 i = 0; i < numJoysticks; ++i) SDL_JoystickClose(Joysticks[i]);
+        #endif
+        if(glContext) SDL_GL_DeleteContext(glContext);
+        if(renderer) SDL_DestroyRenderer(renderer);
+        if(window) SDL_DestroyWindow(window);
+        SDL_Quit();
+    }
+
+    bool CIrrDeviceSDL2::createWindow()
+    {
+        if(!window)
+        {
+            if(CreationParams.DriverType == video::EDT_NULL) winFlags |= SDL_WINDOW_HIDDEN;
+            else winFlags |= SDL_WINDOW_SHOWN;
+
+            if(CreationParams.Fullscreen) winFlags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
+
+            int x = SDL_WINDOWPOS_CENTERED, y = SDL_WINDOWPOS_CENTERED, w = 800, h = 600;
+            if(CreationParams.WindowPosition.X >= 0 && CreationParams.WindowPosition.Y >= 0)
+            {
+                x = CreationParams.WindowPosition.X;
+                y = CreationParams.WindowPosition.Y;
+            }
+            if(CreationParams.WindowSize.Width > 0 && CreationParams.WindowSize.Height > 0)
+            {
+                w = CreationParams.WindowSize.Width;
+                h = CreationParams.WindowSize.Height;
+            }
+            /*
+            CreationParams.WindowId = window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+            /*/
+            if(CreationParams.DriverType == video::EDT_OPENGL
+               || CreationParams.DriverType == video::EDT_OGLES1
+               || CreationParams.DriverType == video::EDT_OGLES2)
+            {
+                winFlags |= SDL_WINDOW_OPENGL;
+                if(CreationParams.DriverType == video::EDT_OPENGL)
+                {
+                    os::Printer::Logger->log("EDT_OPENGL", ELL_DEBUG);
+                    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);
+                }
+                else // if(CreationParams.DriverType & (video::EDT_OGLES1 | video::EDT_OGLES2))
+                {
+                    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES | SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);
+                    if(CreationParams.DriverType == video::EDT_OGLES1)
+                    {
+                        os::Printer::Logger->log("EDT_OGLES1", ELL_DEBUG);
+                        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 1);
+                        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
+                    }
+                    else
+                    {
+                        os::Printer::Logger->log("EDT_OGLES2", ELL_DEBUG);
+                        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
+                        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
+                    }
+                }
+
+                if(CreationParams.Bits < 24)
+                {
+                    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 4);
+                    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 4);
+                    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 4);
+                    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel ? 1 : 0);
+                }
+                else
+                {
+                    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
+                    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
+                    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
+                    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel ? 8 : 0);
+                }
+
+                SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, CreationParams.Bits);
+                SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, CreationParams.ZBufferBits);
+
+                if(CreationParams.Doublebuffer) SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
+                if(CreationParams.Stereobuffer) SDL_GL_SetAttribute(SDL_GL_STEREO, 1);
+                if(CreationParams.AntiAlias > 1)
+                {
+                    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
+                    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias);
+                }
+
+                window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+
+                if(!window && CreationParams.Stereobuffer)
+                {
+                    SDL_GL_SetAttribute(SDL_GL_STEREO, 0);
+                    window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+                    if(window) os::Printer::Logger->log("StereoBuffer disabled due to lack of support!", ELL_WARNING);
+                }
+                if(!window && CreationParams.AntiAlias > 1)
+                {
+                    while(--CreationParams.AntiAlias > 1)
+                    {
+                        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias);
+                        window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+                        if(window) break;
+                    }
+                    if(!window)
+                    {
+                        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+                        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0);
+                        window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+                        if(window) os::Printer::Logger->log("AntiAliasing disabled due to lack of support!", ELL_WARNING);
+                    }
+                }
+                if(!window && CreationParams.Doublebuffer)
+                {
+                    // Try single buffer
+                    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 0);
+                    window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+                    if(window) os::Printer::Logger->log("DoubleBuffer disabled due to lack of support!", ELL_WARNING);
+                }
+            }
+            else window = SDL_CreateWindow(A_TITLE, x, y, w, h, winFlags);
+
+            CreationParams.WindowId = window;
+            if(!window)
+            {
+                os::Printer::Logger->log("Could not initialize Window!", ELL_ERROR);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    bool CIrrDeviceSDL2::createRenderer()
+    {
+        if(Close) return false;
+
+        switch(CreationParams.DriverType)
+        {
+            case video::EDT_OGLES1:
+            case video::EDT_OGLES2:
+            case video::EDT_OPENGL:
+                glContext = SDL_GL_CreateContext(window);
+                if(glContext)
+                {
+                    SDL_GL_SetSwapInterval(CreationParams.Vsync ? 0 : 1);
+                    SDL_GL_MakeCurrent(window, glContext);
+                    return true;
+                }
+                return false;
+            case video::EDT_BURNINGSVIDEO:
+                rendFlags |= SDL_RENDERER_ACCELERATED;
+                break;
+            case video::EDT_SOFTWARE:
+                rendFlags |= SDL_RENDERER_SOFTWARE;
+                break;
+            case video::EDT_NULL:
+                rendFlags |= SDL_RENDERER_TARGETTEXTURE;
+                break;
+            default:
+                return false;
+        }
+        if(CreationParams.Vsync) rendFlags |= SDL_RENDERER_PRESENTVSYNC;
+
+        renderer = SDL_CreateRenderer(window, -1, rendFlags);
+
+        if(renderer)
+        {
+            if(CreationParams.Fullscreen)
+            {
+                SDL_RenderSetLogicalSize(renderer, CreationParams.WindowSize.Width, CreationParams.WindowSize.Height);
+            }
+            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
+            SDL_RenderClear(renderer);
+            SDL_RenderPresent(renderer);
+            return true;
+        }
+        return false;
+    }
+
+    //! create the driver
+    void CIrrDeviceSDL2::createDriver()
+    {
+        switch(CreationParams.DriverType)
+        {
+            case video::EDT_OPENGL:
+                #ifdef _IRR_COMPILE_WITH_OPENGL_
+                VideoDriver = video::createOpenGLDriver(CreationParams, FileSystem, this);
+                #else
+                os::Printer::log("No OpenGL support compiled in.", ELL_ERROR);
+                #endif
+                break;
+
+            case video::EDT_OGLES1:
+                #ifdef _IRR_COMPILE_WITH_OGLES1_
+                ContextManager = new video::CEGLManager();
+                ContextManager->initialize(CreationParams, filler);
+                VideoDriver = video::createOGLES1Driver(CreationParams, FileSystem, ContextManager);
+                #else
+                os::Printer::log("No OGLES1 support compiled in.", ELL_ERROR);
+                #endif
+                break;
+
+            case video::EDT_OGLES2:
+                #ifdef _IRR_COMPILE_WITH_OGLES2_
+                ContextManager = new video::CEGLManager();
+                ContextManager->initialize(CreationParams, filler);
+                VideoDriver = video::createOGLES2Driver(CreationParams, FileSystem, ContextManager);
+                #else
+                os::Printer::log("No OGLES2 support compiled in.", ELL_ERROR);
+                #endif
+                break;
+
+            case video::EDT_BURNINGSVIDEO:
+                #ifdef _IRR_COMPILE_WITH_BURNINGSVIDEO_
+                VideoDriver = video::createBurningVideoDriver(CreationParams, FileSystem, this);
+                #else
+                os::Printer::log("Burning's video driver was not compiled in.", ELL_ERROR);
+                #endif
+                break;
+
+            case video::EDT_SOFTWARE:
+                #ifdef _IRR_COMPILE_WITH_SOFTWARE_
+                VideoDriver = video::createSoftwareDriver(CreationParams.WindowSize, CreationParams.Fullscreen, FileSystem, this);
+                #else
+                os::Printer::log("No Software driver support compiled in.", ELL_ERROR);
+                #endif
+                break;
+
+            case video::EDT_NULL:
+                VideoDriver = video::createNullDriver(FileSystem, CreationParams.WindowSize);
+                break;
+
+            case video::EDT_DIRECT3D8:
+//                #ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+//                VideoDriver = video::createDirectX8Driver(CreationParams, FileSystem, HWnd);
+//                if(!VideoDriver)
+//                {
+//                    os::Printer::log("Could not create DIRECT3D8 Driver.", ELL_ERROR);
+//                }
+//                #else
+                os::Printer::log("DIRECT3D8 Driver is not currently setup for SDL2.", ELL_ERROR);
+//                #endif // _IRR_COMPILE_WITH_DIRECT3D_8_
+                break;
+
+            case video::EDT_DIRECT3D9:
+//                #ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+//                VideoDriver = video::createDirectX9Driver(CreationParams, FileSystem, HWnd);
+//                if(!VideoDriver)
+//                {
+//                    os::Printer::log("Could not create DIRECT3D9 Driver.", ELL_ERROR);
+//                }
+//                #else
+                os::Printer::log("DIRECT3D9 Driver is not currently setup for SDL2.", ELL_ERROR);
+//                #endif // _IRR_COMPILE_WITH_DIRECT3D_9_
+                break;
+
+            default:
+                os::Printer::log("Unable to create video driver of unknown type.", ELL_ERROR);
+                break;
+        }
+    }
+
+    //! runs the device. Returns false if device wants to be deleted
+    bool CIrrDeviceSDL2::run()
+    {
+        os::Timer::tick();
+        SDL_Event SDL_event;
+        bool kHandled = false;
+
+        while(!Close && SDL_PollEvent(&SDL_event))
+        {
+            SEvent irrevent;
+            switch(SDL_event.type)
+            {
+                case SDL_QUIT:
+                    {
+                        os::Printer::Logger->log("SDL_QUIT", ELL_DEBUG);
+                        Close = true;
+                        return false;
+                    }
+                    break;
+                case SDL_APP_TERMINATING:
+                    {
+                        os::Printer::Logger->log("SDL_APP_TERMINATING", ELL_DEBUG);
+                        Close = true;
+                        return false;
+                    }
+                    break;
+                case SDL_APP_LOWMEMORY:
+                    {
+                        os::Printer::Logger->log("SDL_APP_LOWMEMORY", ELL_WARNING);
+                    }
+                    break;
+                case SDL_APP_WILLENTERBACKGROUND:
+                    {
+                        os::Printer::Logger->log("SDL_APP_WILLENTERBACKGROUND", ELL_DEBUG);
+                        WindowHasFocus = false;
+                        WindowMinimized = true;
+                    }
+                    break;
+                case SDL_APP_DIDENTERBACKGROUND:
+                    {
+                        os::Printer::Logger->log("SDL_APP_DIDENTERBACKGROUND", ELL_DEBUG);
+                        WindowHasFocus = false;
+                        WindowMinimized = true;
+                    }
+                    break;
+                case SDL_APP_WILLENTERFOREGROUND:
+                    {
+                        os::Printer::Logger->log("SDL_APP_WILLENTERFOREGROUND", ELL_DEBUG);
+                        WindowHasFocus = true;
+                        WindowMinimized = false;
+                    }
+                    break;
+                case SDL_APP_DIDENTERFOREGROUND:
+                    {
+                        os::Printer::Logger->log("SDL_APP_DIDENTERFOREGROUND", ELL_DEBUG);
+                        WindowHasFocus = true;
+                        WindowMinimized = false;
+                    }
+                    break;
+                case SDL_WINDOWEVENT:
+                    {
+                        os::Printer::Logger->log("SDL_WINDOWEVENT", ELL_DEBUG);
+                        switch(SDL_event.window.event)
+                        {
+                            case SDL_WINDOWEVENT_SHOWN:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_SHOWN::Window %d shown", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = false;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_HIDDEN:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_HIDDEN::Window %d hidden", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = true;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_EXPOSED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_EXPOSED::Window %d exposed", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = false;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_MOVED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_MOVED::Window %d moved to %d,%d",
+                                            SDL_event.window.windowID, SDL_event.window.data1, SDL_event.window.data2);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_RESIZED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_RESIZED::Window %d resized to %dx%d",
+                                            SDL_event.window.windowID, SDL_event.window.data1, SDL_event.window.data2);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    updateWindowSize();
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_SIZE_CHANGED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_SIZE_CHANGED::Window %d size changed to %dx%d",
+                                            SDL_event.window.windowID, SDL_event.window.data1, SDL_event.window.data2);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    updateWindowSize();
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_MINIMIZED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_MINIMIZED::Window %d minimized", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = true;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_MAXIMIZED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_MAXIMIZED::Window %d maximized", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = false;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_RESTORED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_RESTORED::Window %d restored", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowMinimized = false;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_ENTER:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_ENTER::Mouse entered window %d", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_LEAVE:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_LEAVE::Mouse left window %d", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_FOCUS_GAINED:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_LEAVE::Window %d gained keyboard focus", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowHasFocus = true;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_FOCUS_LOST:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_LEAVE::Window %d lost keyboard focus", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    WindowHasFocus = false;
+                                }
+                                break;
+                            case SDL_WINDOWEVENT_CLOSE:
+                                {
+                                    char m[300];
+                                    sprintf(m, "SDL_WINDOWEVENT_CLOSE::Window %d closed", SDL_event.window.windowID);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                    Close = true;
+                                    return false;
+                                }
+                                break;
+                            default:
+                                {
+                                    char m[300];
+                                    sprintf(m, "Window %d got unknown event %d", SDL_event.window.windowID, SDL_event.window.event);
+                                    os::Printer::Logger->log(m, ELL_DEBUG);
+                                }
+                                break;
+                        }
+                    }
+                    break;
+                case SDL_SYSWMEVENT:
+                    {
+                        os::Printer::Logger->log("SDL_SYSWMEVENT", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_KEYDOWN:
+                    {
+                        os::Printer::Logger->log("SDL_KEYDOWN", ELL_DEBUG);
+                        kHandled = true;
+
+                        SKeyMap key(SDL_event.key.keysym.sym, KEY_UNKNOWN);
+                        s32 idx = KeyMap.binary_search(key);
+
+                        if(idx > -1) key.IrrKey = KeyMap[idx].IrrKey;
+
+                        irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
+                        irrevent.KeyInput.Char = (wchar_t)SDL_event.key.keysym.sym;
+                        irrevent.KeyInput.Key = (EKEY_CODE)key.IrrKey;
+                        irrevent.KeyInput.PressedDown = true;
+                        irrevent.KeyInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+                        irrevent.KeyInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+
+                        postEventFromUser(irrevent);
+
+                    }
+                    break;
+                case SDL_KEYUP:
+                    {
+                        os::Printer::Logger->log("SDL_KEYUP", ELL_DEBUG);
+                        SKeyMap key(SDL_event.key.keysym.sym, KEY_UNKNOWN);
+                        s32 idx = KeyMap.binary_search(key);
+
+                        if(idx > -1) key.IrrKey = KeyMap[idx].IrrKey;
+
+                        irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
+                        irrevent.KeyInput.Char = (wchar_t)SDL_event.key.keysym.sym;
+                        irrevent.KeyInput.Key = (EKEY_CODE)key.IrrKey;
+                        irrevent.KeyInput.PressedDown = false;
+                        irrevent.KeyInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+                        irrevent.KeyInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+
+                        postEventFromUser(irrevent);
+
+                        wchar_t test = (wchar_t)irrevent.KeyInput.Key;
+                        os::Printer::Logger->log(&test, ELL_DEBUG);
+                        kHandled = false;
+                    }
+                    break;
+                case SDL_TEXTEDITING:
+                    {
+                        os::Printer::Logger->log("SDL_TEXTEDITING", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_TEXTINPUT:
+                    {
+                        os::Printer::Logger->log("SDL_TEXTINPUT", ELL_DEBUG);
+                        if(!kHandled)
+                        {
+                            wchar_t wc;
+                            core::utf8ToWchar(&SDL_event.text.text[0], &wc, 1);
+
+                            SKeyMap key((s32)wc, KEY_UNKNOWN);
+                            s32 idx = KeyMap.binary_search(key);
+
+                            if(idx > -1) key.IrrKey = KeyMap[idx].IrrKey;
+
+                            irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
+                            irrevent.KeyInput.Char = wc;
+                            irrevent.KeyInput.Key = (EKEY_CODE)key.IrrKey;
+                            irrevent.KeyInput.PressedDown = true;
+                            irrevent.KeyInput.Control = false;
+                            irrevent.KeyInput.Shift = false;
+
+                            postEventFromUser(irrevent);
+                            irrevent.KeyInput.PressedDown = false;
+                            postEventFromUser(irrevent);
+
+                            os::Printer::Logger->log(&irrevent.KeyInput.Char, ELL_DEBUG);
+                        }
+                    }
+                    break;
+                case SDL_MOUSEMOTION:
+                    {
+                        os::Printer::Logger->log("SDL_MOUSEMOTION", ELL_DEBUG);
+                        if(SDL_event.motion.which != SDL_TOUCH_MOUSEID)
+                        {
+                            irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+                            irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+                            MouseX = irrevent.MouseInput.X = SDL_event.motion.x;
+                            MouseY = irrevent.MouseInput.Y = SDL_event.motion.y;
+                            MouseButtonStates = SDL_event.motion.state & SDL_BUTTON_LMASK ? irr::EMBSM_LEFT : 0;
+                            MouseButtonStates |= SDL_event.motion.state & SDL_BUTTON_MMASK ? irr::EMBSM_MIDDLE : 0;
+                            MouseButtonStates |= SDL_event.motion.state & SDL_BUTTON_RMASK ? irr::EMBSM_RIGHT : 0;
+                            MouseButtonStates |= SDL_event.motion.state & SDL_BUTTON_X1MASK ? irr::EMBSM_EXTRA1 : 0;
+                            MouseButtonStates |= SDL_event.motion.state & SDL_BUTTON_X2MASK ? irr:: EMBSM_EXTRA2 : 0;
+                            irrevent.MouseInput.ButtonStates = MouseButtonStates;
+                            irrevent.MouseInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+                            irrevent.MouseInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+
+                            postEventFromUser(irrevent);
+                        }
+                    }
+                    break;
+                case SDL_MOUSEBUTTONDOWN:
+                    {
+                        os::Printer::Logger->log("SDL_MOUSEBUTTONDOWN", ELL_DEBUG);
+                        if(SDL_event.button.which != SDL_TOUCH_MOUSEID)
+                        {
+                            irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+                            MouseX = irrevent.MouseInput.X = SDL_event.button.x;
+                            MouseY = irrevent.MouseInput.Y = SDL_event.button.y;
+                            irrevent.MouseInput.ButtonStates = MouseButtonStates;
+                            irrevent.MouseInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+                            irrevent.MouseInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+
+                            switch(SDL_event.button.button)
+                            {
+                                case SDL_BUTTON_LEFT:
+                                    os::Printer::Logger->log("SDL_BUTTON_LEFT", ELL_DEBUG);
+                                    switch(SDL_event.button.clicks)
+                                    {
+                                        case 1:
+                                            os::Printer::Logger->log("single click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
+                                            break;
+                                        case 2:
+                                            os::Printer::Logger->log("double click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_LMOUSE_DOUBLE_CLICK;
+                                            break;
+                                        case 3:
+                                            os::Printer::Logger->log("triple click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_LMOUSE_TRIPLE_CLICK;
+                                            break;
+                                        default:
+                                            os::Printer::Logger->log("unhandled click count", ELL_DEBUG);
+                                            break;
+                                    }
+                                    break;
+                                case SDL_BUTTON_RIGHT:
+                                    os::Printer::Logger->log("SDL_BUTTON_RIGHT", ELL_DEBUG);
+                                    switch(SDL_event.button.clicks)
+                                    {
+                                        case 1:
+                                            os::Printer::Logger->log("single click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_RMOUSE_PRESSED_DOWN;
+                                            break;
+                                        case 2:
+                                            os::Printer::Logger->log("double click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_RMOUSE_DOUBLE_CLICK;
+                                            break;
+                                        case 3:
+                                            os::Printer::Logger->log("triple click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_RMOUSE_TRIPLE_CLICK;
+                                            break;
+                                        default:
+                                            os::Printer::Logger->log("unhandled click count", ELL_DEBUG);
+                                            break;
+                                    }
+                                    break;
+                                case SDL_BUTTON_MIDDLE:
+                                    os::Printer::Logger->log("SDL_BUTTON_MIDDLE", ELL_DEBUG);
+                                    switch(SDL_event.button.clicks)
+                                    {
+                                        case 1:
+                                            os::Printer::Logger->log("single click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_MMOUSE_PRESSED_DOWN;
+                                            break;
+                                        case 2:
+                                            os::Printer::Logger->log("double click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_MMOUSE_DOUBLE_CLICK;
+                                            break;
+                                        case 3:
+                                            os::Printer::Logger->log("triple click", ELL_DEBUG);
+                                            irrevent.MouseInput.Event = irr::EMIE_MMOUSE_TRIPLE_CLICK;
+                                            break;
+                                        default:
+                                            os::Printer::Logger->log("unhandled click count", ELL_DEBUG);
+                                            break;
+                                    }
+                                    break;
+                                default:
+                                    os::Printer::Logger->log("unhandled sdl mouse button down event", ELL_DEBUG);
+                                    break;
+                            }
+
+                            postEventFromUser(irrevent);
+                        }
+                    }
+                    break;
+                case SDL_MOUSEBUTTONUP:
+                    {
+                        os::Printer::Logger->log("SDL_MOUSEBUTTONUP", ELL_DEBUG);
+                        if(SDL_event.button.which != SDL_TOUCH_MOUSEID)
+                        {
+                            irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+                            MouseX = irrevent.MouseInput.X = SDL_event.button.x;
+                            MouseY = irrevent.MouseInput.Y = SDL_event.button.y;
+                            irrevent.MouseInput.ButtonStates = MouseButtonStates;
+                            irrevent.MouseInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+                            irrevent.MouseInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+
+                            switch(SDL_event.button.button)
+                            {
+                                case SDL_BUTTON_LEFT:
+                                    os::Printer::Logger->log("SDL_BUTTON_LEFT", ELL_DEBUG);
+                                    irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
+                                    break;
+                                case SDL_BUTTON_RIGHT:
+                                    os::Printer::Logger->log("SDL_BUTTON_RIGHT", ELL_DEBUG);
+                                    irrevent.MouseInput.Event = irr::EMIE_RMOUSE_LEFT_UP;
+                                    break;
+                                case SDL_BUTTON_MIDDLE:
+                                    os::Printer::Logger->log("SDL_BUTTON_MIDDLE", ELL_DEBUG);
+                                    irrevent.MouseInput.Event = irr::EMIE_MMOUSE_LEFT_UP;
+                                    break;
+                                default:
+                                    os::Printer::Logger->log("unhandled sdl mouse button up event", ELL_DEBUG);
+                                    break;
+                            }
+
+                            postEventFromUser(irrevent);
+                        }
+                    }
+                    break;
+                case SDL_MOUSEWHEEL:
+                    {
+                        os::Printer::Logger->log("SDL_MOUSEWHEEL", ELL_DEBUG);
+                        if(SDL_event.button.which != SDL_TOUCH_MOUSEID)
+                        {
+                            irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+                            MouseX = irrevent.MouseInput.X = SDL_event.button.x;
+                            MouseY = irrevent.MouseInput.Y = SDL_event.button.y;
+                            irrevent.MouseInput.ButtonStates = MouseButtonStates;
+                            irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
+                            irrevent.MouseInput.Wheel = (f32)SDL_event.wheel.x;
+                            irrevent.MouseInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL) != 0;
+                            irrevent.MouseInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+
+                            postEventFromUser(irrevent);
+                        }
+                    }
+                    break;
+                #ifdef _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
+                case SDL_JOYAXISMOTION:
+                    {
+                        SDL_JoyAxisEvent jaxis = SDL_event.jaxis;
+                        char logString[256];
+                        sprintf(logString, "SDL_JOYAXISMOTION: axis %d, value %d", jaxis.axis, jaxis.value);
+                        os::Printer::Logger->log(logString, ELL_DEBUG);
+                    }
+                    break;
+                case SDL_JOYBALLMOTION:
+                    {
+                        os::Printer::Logger->log("SDL_JOYBALLMOTION", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_JOYHATMOTION:
+                    {
+                        os::Printer::Logger->log("SDL_JOYHATMOTION", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_JOYBUTTONDOWN:
+                    {
+                        os::Printer::Logger->log("SDL_JOYBUTTONDOWN", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_JOYBUTTONUP:
+                    {
+                        os::Printer::Logger->log("SDL_JOYBUTTONUP", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_JOYDEVICEADDED:
+                    {
+                        os::Printer::Logger->log("SDL_JOYDEVICEADDED", ELL_DEBUG);
+                        int j = SDL_event.jdevice.which;
+
+                        SDL_Joystick* joy = SDL_JoystickOpen(j);
+                        if(j < Joysticks.size()) Joysticks.erase(j);
+                        Joysticks.insert(joy, j);
+
+                        SJoystickInfo info;
+                        info.Joystick = j;
+                        info.Axes = SDL_JoystickNumAxes(joy);
+                        info.Buttons = SDL_JoystickNumButtons(joy);
+                        info.Name = SDL_JoystickName(joy);
+                        info.PovHat = (SDL_JoystickNumHats(joy) > 0) ? SJoystickInfo::POV_HAT_PRESENT : SJoystickInfo::POV_HAT_ABSENT;
+                        if(joyinfo)
+                        {
+                            if(j < joyinfo->size()) joyinfo->erase(j);
+                            joyinfo->insert(info, j);
+                        }
+
+                        char logString[256];
+                        sprintf(logString, "Found joystick %d ('%s'): %d axes, %d buttons, %s POV hat",
+                                j, info.Name.c_str(), info.Axes, info.Buttons, info.PovHat == SJoystickInfo::POV_HAT_PRESENT ? "with" : "no");
+                        os::Printer::log(logString, ELL_INFORMATION);
+                    }
+                    break;
+                case SDL_JOYDEVICEREMOVED:
+                    {
+                        os::Printer::Logger->log("SDL_JOYDEVICEREMOVED", ELL_DEBUG);
+                        int j = SDL_event.jdevice.which;
+
+                        char logString[256];
+                        sprintf(logString, "Lost joystick %d ('%s')", j, SDL_JoystickName(Joysticks[j]));
+                        os::Printer::log(logString, ELL_INFORMATION);
+
+                        SDL_JoystickClose(Joysticks[SDL_event.jdevice.which]);
+                    }
+                    break;
+                case SDL_CONTROLLERAXISMOTION:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERAXISMOTION", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CONTROLLERBUTTONDOWN:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERBUTTONDOWN", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CONTROLLERBUTTONUP:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERBUTTONUP", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CONTROLLERDEVICEADDED:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERDEVICEADDED", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CONTROLLERDEVICEREMOVED:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERDEVICEREMOVED", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CONTROLLERDEVICEREMAPPED:
+                    {
+                        os::Printer::Logger->log("SDL_CONTROLLERDEVICEREMAPPED", ELL_DEBUG);
+                    }
+                    break;
+                #endif // _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
+                case SDL_FINGERDOWN:
+                    {
+                        os::Printer::Logger->log("SDL_FINGERDOWN", ELL_DEBUG);
+                        irrevent.EventType = irr::EET_TOUCH_INPUT_EVENT;
+                        irrevent.TouchInput.ID = SDL_event.tfinger.fingerId;
+                        irrevent.TouchInput.X = SDL_event.tfinger.x * (s32)Width;
+                        irrevent.TouchInput.Y = SDL_event.tfinger.y * (s32)Height;
+                        irrevent.TouchInput.Event = irr::ETIE_PRESSED_DOWN;
+
+                        postEventFromUser(irrevent);
+                    }
+                    break;
+                case SDL_FINGERUP:
+                    {
+                        os::Printer::Logger->log("SDL_FINGERUP", ELL_DEBUG);
+                        irrevent.EventType = irr::EET_TOUCH_INPUT_EVENT;
+                        irrevent.TouchInput.ID = SDL_event.tfinger.fingerId;
+                        irrevent.TouchInput.X = SDL_event.tfinger.x * (s32)Width;
+                        irrevent.TouchInput.Y = SDL_event.tfinger.y * (s32)Height;
+                        irrevent.TouchInput.Event = irr::ETIE_LEFT_UP;
+
+                        postEventFromUser(irrevent);
+                    }
+                    break;
+                case SDL_FINGERMOTION:
+                    {
+                        os::Printer::Logger->log("SDL_FINGERMOTION", ELL_DEBUG);
+                        irrevent.EventType = irr::EET_TOUCH_INPUT_EVENT;
+                        irrevent.TouchInput.ID = SDL_event.tfinger.fingerId;
+                        irrevent.TouchInput.X = SDL_event.tfinger.x * (s32)Width;
+                        irrevent.TouchInput.Y = SDL_event.tfinger.y * (s32)Height;
+                        irrevent.TouchInput.Event = irr::ETIE_MOVED;
+
+                        postEventFromUser(irrevent);
+                    }
+                    break;
+                case SDL_DOLLARGESTURE:
+                    {
+                        os::Printer::Logger->log("SDL_DOLLARGESTURE", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_DOLLARRECORD:
+                    {
+                        os::Printer::Logger->log("SDL_DOLLARRECORD", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_MULTIGESTURE:
+                    {
+                        os::Printer::Logger->log("SDL_MULTIGESTURE", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_CLIPBOARDUPDATE:
+                    {
+                        os::Printer::Logger->log("SDL_CLIPBOARDUPDATE", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_DROPFILE:
+                    {
+                        os::Printer::Logger->log("SDL_DROPFILE", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_RENDER_TARGETS_RESET:
+                    {
+                        os::Printer::Logger->log("SDL_RENDER_TARGETS_RESET", ELL_DEBUG);
+                    }
+                    break;
+                case SDL_USEREVENT:
+                    {
+                        os::Printer::Logger->log("SDL_USEREVENT", ELL_DEBUG);
+                        irrevent.EventType = irr::EET_USER_EVENT;
+                        irrevent.UserEvent.UserData1 = *(reinterpret_cast<s32*>(&SDL_event.user.data1));
+                        irrevent.UserEvent.UserData2 = *(reinterpret_cast<s32*>(&SDL_event.user.data2));
+
+                        postEventFromUser(irrevent);
+                    }
+                    break;
+                default:
+                    {
+                        char m[300];
+                        sprintf(m, "unknown/unhandled event %d", SDL_event.type);
+                        os::Printer::Logger->log(m, ELL_DEBUG);
+                    }
+                    break;
+            } // end switch
+
+        } // end while
+
+        #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+        // TODO: Check if the multiple open/close calls are too expensive, then
+        // open/close in the constructor/destructor instead
+
+        // we'll always send joystick input events...
+        SEvent joyevent;
+        joyevent.EventType = EET_JOYSTICK_INPUT_EVENT;
+        for(u32 i = 0; i < Joysticks.size(); ++i)
+        {
+            SDL_Joystick* joystick = Joysticks[i];
+            int j;
+            // query all buttons
+            const int numButtons = core::min_(SDL_JoystickNumButtons(joystick), 32);
+            joyevent.JoystickEvent.ButtonStates = 0;
+            for(j = 0; j < numButtons; ++j)
+                joyevent.JoystickEvent.ButtonStates |= (SDL_JoystickGetButton(joystick, j)<<j);
+
+            // query all axes, already in correct range
+            const int numAxes = core::min_(SDL_JoystickNumAxes(joystick), (int)SEvent::SJoystickEvent::NUMBER_OF_AXES);
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_X] = 0;
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Y] = 0;
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Z] = 0;
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_R] = 0;
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_U] = 0;
+            joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_V] = 0;
+            for(j = 0; j < numAxes; ++j) joyevent.JoystickEvent.Axis[j] = SDL_JoystickGetAxis(joystick, j);
+
+            // we can only query one hat, SDL only supports 8 directions
+            joyevent.JoystickEvent.POV = 65535; // center/none
+            if(SDL_JoystickNumHats(joystick) > 0)
+            {
+                switch(SDL_JoystickGetHat(joystick, 0))
+                {
+                    case SDL_HAT_UP:
+                        joyevent.JoystickEvent.POV = 0;
+                        break;
+                    case SDL_HAT_RIGHTUP:
+                        joyevent.JoystickEvent.POV = 4500;
+                        break;
+                    case SDL_HAT_RIGHT:
+                        joyevent.JoystickEvent.POV = 9000;
+                        break;
+                    case SDL_HAT_RIGHTDOWN:
+                        joyevent.JoystickEvent.POV = 13500;
+                        break;
+                    case SDL_HAT_DOWN:
+                        joyevent.JoystickEvent.POV = 18000;
+                        break;
+                    case SDL_HAT_LEFTDOWN:
+                        joyevent.JoystickEvent.POV = 22500;
+                        break;
+                    case SDL_HAT_LEFT:
+                        joyevent.JoystickEvent.POV = 27000;
+                        break;
+                    case SDL_HAT_LEFTUP:
+                        joyevent.JoystickEvent.POV = 31500;
+                        break;
+                    case SDL_HAT_CENTERED:
+                    default:
+                        break;
+                }
+            }
+
+            // we map the number directly
+            joyevent.JoystickEvent.Joystick = static_cast<u8>(i);
+            // now post the event
+            postEventFromUser(joyevent);
+            // and close the joystick
+        }
+        #endif
+        return !Close;
+    }
+
+    void CIrrDeviceSDL2::updateWindowSize()
+    {
+        int w, h;
+        if(glContext) SDL_GL_GetDrawableSize(window, &w, &h);
+        else SDL_GetWindowSize(window, &w, &h);
+        if(w > 0) Width = (u32)w;
+        if(h > 0) Height = (u32)h;
+        VideoDriver->OnResize(core::dimension2du(Width, Height));
+        char l[200];
+        sprintf(l, "Viewport size is %dx%d", Width, Height);
+        os::Printer::Logger->log(l, ELL_DEBUG);
+
+        if(SceneManager)
+        {
+            scene::ICameraSceneNode* cam = SceneManager->getActiveCamera();
+            if(cam)
+            {
+                cam->setAspectRatio((f32)Width / (f32)Height);
+
+                sprintf(l, "Camera aspect ratio is %.4f", cam->getAspectRatio());
+                os::Printer::Logger->log(l, ELL_DEBUG);
+            }
+        }
+    }
+
+    //! Sets a new event receiver to receive events
+    void CIrrDeviceSDL2::setEventReceiver(IEventReceiver* receiver)
+    {
+        if(!sdlEventReceiver) sdlEventReceiver = new SDL2EventReceiver();
+        sdlEventReceiver->actual = receiver;
+        CIrrDeviceStub::setEventReceiver(sdlEventReceiver);
+    }
+
+    //! Activate any joysticks, and generate events for them.
+    bool CIrrDeviceSDL2::activateJoysticks(core::array<SJoystickInfo> &joystickInfo)
+    {
+        #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+        joystickInfo.clear();
+
+        int joystick = 0;
+        for(; joystick < Joysticks.size(); joystick++)
+        {
+            SJoystickInfo info;
+
+            info.Joystick = joystick;
+            info.Axes = SDL_JoystickNumAxes(Joysticks[joystick]);
+            info.Buttons = SDL_JoystickNumButtons(Joysticks[joystick]);
+            info.Name = SDL_JoystickName(Joysticks[joystick]);
+            info.PovHat = (SDL_JoystickNumHats(Joysticks[joystick]) > 0)
+                            ? SJoystickInfo::POV_HAT_PRESENT : SJoystickInfo::POV_HAT_ABSENT;
+
+            joystickInfo.push_back(info);
+
+            char logString[256];
+            sprintf(logString, "Found joystick %d ('%s'): %d axes, %d buttons, %s POV hat",
+                    joystick, info.Name.c_str(), info.Axes, info.Buttons, info.PovHat == SJoystickInfo::POV_HAT_PRESENT ? "with" : "no");
+            os::Printer::log(logString, ELL_INFORMATION);
+        }
+        joyinfo = &joystickInfo;
+
+        return true;
+        #else
+        return false;
+        #endif // _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
+    }
+
+    //! pause execution temporarily
+    void CIrrDeviceSDL2::yield()
+    {
+        sleep(0, false);
+    }
+
+    //! pause execution for a specified time
+    void CIrrDeviceSDL2::sleep(u32 timeMs, bool pauseTimer)
+    {
+        const bool wasStopped = Timer ? Timer->isStopped() : true;
+        if(pauseTimer && !wasStopped) Timer->stop();
+        SDL_Delay(timeMs);
+        if(pauseTimer && !wasStopped) Timer->start();
+    }
+
+    //! sets the caption of the window
+    void CIrrDeviceSDL2::setWindowCaption(const wchar_t* text)
+    {
+        core::stringc textc = text;
+        SDL_SetWindowTitle(window, textc.c_str());
+    }
+
+    //! presents a surface in the client area
+    bool CIrrDeviceSDL2::present(video::IImage* irrSurface, void* windowId, core::recti* srcClip)
+    {
+        SDL_Surface *sdlSurface = SDL_CreateRGBSurfaceFrom(irrSurface->lock(),
+                irrSurface->getDimension().Width, irrSurface->getDimension().Height,
+                irrSurface->getBitsPerPixel(), irrSurface->getPitch(), irrSurface->getRedMask(),
+                irrSurface->getGreenMask(), irrSurface->getBlueMask(), irrSurface->getAlphaMask());
+        if(!sdlSurface) return false;
+        //SDL_SetAlpha(sdlSurface, 0, 0); // what is this doing?
+        //SDL_SetColorKey(sdlSurface, 0, 0); // what is this doing?
+        sdlSurface->format->BitsPerPixel = irrSurface->getBitsPerPixel();
+        sdlSurface->format->BytesPerPixel = irrSurface->getBytesPerPixel();
+        switch(irrSurface->getColorFormat())
+        {
+            case video::ECF_R8G8B8:
+            case video::ECF_A8R8G8B8:
+                sdlSurface->format->Rloss = 0;
+                sdlSurface->format->Gloss = 0;
+                sdlSurface->format->Bloss = 0;
+                sdlSurface->format->Rshift = 16;
+                sdlSurface->format->Gshift = 8;
+                sdlSurface->format->Bshift = 0;
+                if(irrSurface->getColorFormat() == video::ECF_R8G8B8)
+                {
+                    sdlSurface->format->Aloss = 8;
+                    sdlSurface->format->Ashift = 32;
+                }
+                else
+                {
+                    sdlSurface->format->Aloss = 0;
+                    sdlSurface->format->Ashift = 24;
+                }
+                break;
+            case video::ECF_R5G6B5:
+                sdlSurface->format->Rloss = 3;
+                sdlSurface->format->Gloss = 2;
+                sdlSurface->format->Bloss = 3;
+                sdlSurface->format->Aloss = 8;
+                sdlSurface->format->Rshift = 11;
+                sdlSurface->format->Gshift = 5;
+                sdlSurface->format->Bshift = 0;
+                sdlSurface->format->Ashift = 16;
+                break;
+            case video::ECF_A1R5G5B5:
+                sdlSurface->format->Rloss = 3;
+                sdlSurface->format->Gloss = 3;
+                sdlSurface->format->Bloss = 3;
+                sdlSurface->format->Aloss = 7;
+                sdlSurface->format->Rshift = 10;
+                sdlSurface->format->Gshift = 5;
+                sdlSurface->format->Bshift = 0;
+                sdlSurface->format->Ashift = 15;
+                break;
+            default:
+                break;
+        }
+
+        if(renderer)
+        {
+            SDL_Texture* sdlTexture = SDL_CreateTextureFromSurface(renderer, sdlSurface);
+            if(sdlTexture)
+            {
+                SDL_UpdateTexture(sdlTexture, NULL, sdlSurface->pixels, sdlSurface->pitch);
+                if(srcClip)
+                {
+                    SDL_Rect sdlsrcClip;
+                    sdlsrcClip.x = srcClip->UpperLeftCorner.X;
+                    sdlsrcClip.y = srcClip->UpperLeftCorner.Y;
+                    sdlsrcClip.w = srcClip->getWidth();
+                    sdlsrcClip.h = srcClip->getHeight();
+                    SDL_RenderCopy(renderer, sdlTexture, &sdlsrcClip, NULL);
+                }
+                else SDL_RenderCopy(renderer, sdlTexture, NULL, NULL);
+            }
+            else
+            {
+                os::Printer::log("Error creating SDL_Texture: %s", SDL_GetError());
+            }
+            SDL_RenderPresent(renderer);
+            SDL_DestroyTexture(sdlTexture);
+        }
+
+        SDL_FreeSurface(sdlSurface);
+        irrSurface->unlock();
+        return true;//sdlTexture != NULL;
+    }
+
+    //! notifies the device that it should close itself
+    void CIrrDeviceSDL2::closeDevice()
+    {
+        Close = true;
+    }
+
+    //! \return Pointer to a list with all video modes supported
+    video::IVideoModeList* CIrrDeviceSDL2::getVideoModeList()
+    {
+        if(!VideoModeList->getVideoModeCount())
+        {
+            // enumerate video modes.
+            SDL_DisplayMode current;
+            for(int i = 0; i < SDL_GetNumVideoDisplays(); ++i)
+            {
+                if(SDL_GetCurrentDisplayMode(i, &current) == 0)
+                {
+                    VideoModeList->addMode(core::dimension2du(current.w, current.h), SDL_BITSPERPIXEL(current.format));
+                }
+                else
+                {
+                    char msg[300];
+                    sprintf(msg, "Could not get display mode for video display #%d: %s", i, SDL_GetError());
+                    os::Printer::Logger->log(msg, ELL_DEBUG);
+                }
+            }
+        }
+
+        return VideoModeList;
+    }
+
+    //! Sets if the window should be resizable in windowed mode.
+    void CIrrDeviceSDL2::setResizable(bool resize)
+    {
+        // meh... leave it always resizable - let SDL take care of stuff.
+    }
+
+    //! Minimizes window if possible
+    void CIrrDeviceSDL2::minimizeWindow()
+    {
+        SDL_MinimizeWindow(window);
+        WindowMinimized = true;
+        WindowHasFocus = false;
+    }
+
+    //! Maximize window
+    void CIrrDeviceSDL2::maximizeWindow()
+    {
+        SDL_MaximizeWindow(window);
+        WindowMinimized = false;
+        WindowHasFocus = true;
+    }
+
+    //! Get the position of this window on screen
+    core::position2di CIrrDeviceSDL2::getWindowPosition()
+    {
+        int x, y;
+        SDL_GetWindowPosition(window, &x, &y);
+        return core::position2di(s32(x), s32(y));
+    }
+
+    //! Restore original window size
+    void CIrrDeviceSDL2::restoreWindow()
+    {
+        SDL_RestoreWindow(window);
+        WindowMinimized = false;
+    }
+
+    //! returns if window is active. if not, nothing need to be drawn
+    bool CIrrDeviceSDL2::isWindowActive() const
+    {
+        return WindowHasFocus || SDL_GetMouseFocus() == window || SDL_GetKeyboardFocus() == window;// (WindowHasFocus && !WindowMinimized);
+    }
+
+    //! returns if window has focus.
+    bool CIrrDeviceSDL2::isWindowFocused() const
+    {
+        return WindowHasFocus || SDL_GetMouseFocus() == window || SDL_GetKeyboardFocus() == window;
+    }
+
+    //! returns if window is minimized.
+    bool CIrrDeviceSDL2::isWindowMinimized() const
+    {
+        return WindowMinimized;
+    }
+
+    //! Set the current Gamma Value for the Display
+    bool CIrrDeviceSDL2::setGammaRamp(f32 red, f32 green, f32 blue, f32 brightness, f32 contrast)
+    {
+        //! TODO -- https://wiki.libsdl.org/SDL_SetWindowGammaRamp
+        //! manual...
+        return false;
+    }
+
+    //! Get the current Gamma Value for the Display
+    bool CIrrDeviceSDL2::getGammaRamp(f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast)
+    {
+        //! TODO -- https://wiki.libsdl.org/SDL_GetWindowGammaRamp
+        //! manual...
+        return false;
+    }
+
+    //! returns color format of the window.
+    video::ECOLOR_FORMAT CIrrDeviceSDL2::getColorFormat() const
+    {
+        if(window)
+        {
+            u32 cfrmt = SDL_GetWindowPixelFormat(window);
+            if(SDL_BITSPERPIXEL(cfrmt) < 24)
+            {
+                if(SDL_ISPIXELFORMAT_ALPHA(cfrmt)) return video::ECF_A1R5G5B5;
+                else return video::ECF_R5G6B5;
+            }
+            else
+            {
+                if(SDL_ISPIXELFORMAT_ALPHA(cfrmt)) return video::ECF_A8R8G8B8;
+                else return video::ECF_R8G8B8;
+            }
+        }
+        return CIrrDeviceStub::getColorFormat();
+    }
+
+    void CIrrDeviceSDL2::createKeyMap()
+    {
+        // I don't know if this is the best method  to create
+        // the lookuptable, but I'll leave it like that until
+        // I find a better version.
+
+        KeyMap.reallocate(105);
+
+        KeyMap.push_back(SKeyMap(SDLK_0, KEY_KEY_0));
+        KeyMap.push_back(SKeyMap(SDLK_1, KEY_KEY_1));
+        KeyMap.push_back(SKeyMap(SDLK_2, KEY_KEY_2));
+        KeyMap.push_back(SKeyMap(SDLK_3, KEY_KEY_3));
+        KeyMap.push_back(SKeyMap(SDLK_4, KEY_KEY_4));
+        KeyMap.push_back(SKeyMap(SDLK_5, KEY_KEY_5));
+        KeyMap.push_back(SKeyMap(SDLK_6, KEY_KEY_6));
+        KeyMap.push_back(SKeyMap(SDLK_7, KEY_KEY_7));
+        KeyMap.push_back(SKeyMap(SDLK_8, KEY_KEY_8));
+        KeyMap.push_back(SKeyMap(SDLK_9, KEY_KEY_9));
+        KeyMap.push_back(SKeyMap(SDLK_a, KEY_KEY_A));
+        KeyMap.push_back(SKeyMap(SDLK_APPLICATION, KEY_APPS));
+        KeyMap.push_back(SKeyMap(SDLK_AUDIOPLAY, KEY_PLAY));
+        KeyMap.push_back(SKeyMap(SDLK_b, KEY_KEY_B));
+        KeyMap.push_back(SKeyMap(SDLK_BACKSPACE, KEY_BACK));
+        KeyMap.push_back(SKeyMap(SDLK_c, KEY_KEY_C));
+        KeyMap.push_back(SKeyMap(SDLK_CAPSLOCK, KEY_CAPITAL));
+        KeyMap.push_back(SKeyMap(SDLK_CLEAR, KEY_CLEAR));
+        KeyMap.push_back(SKeyMap(SDLK_COMMA,  KEY_COMMA));
+        KeyMap.push_back(SKeyMap(SDLK_CRSEL,  KEY_CRSEL));
+        KeyMap.push_back(SKeyMap(SDLK_d, KEY_KEY_D));
+        KeyMap.push_back(SKeyMap(SDLK_DELETE, KEY_DELETE));
+        KeyMap.push_back(SKeyMap(SDLK_DOWN, KEY_DOWN));
+        KeyMap.push_back(SKeyMap(SDLK_e, KEY_KEY_E));
+        KeyMap.push_back(SKeyMap(SDLK_END, KEY_END));
+        KeyMap.push_back(SKeyMap(SDLK_ESCAPE, KEY_ESCAPE));
+        KeyMap.push_back(SKeyMap(SDLK_EXECUTE, KEY_EXECUT));
+        KeyMap.push_back(SKeyMap(SDLK_EXSEL, KEY_EXSEL));
+        KeyMap.push_back(SKeyMap(SDLK_f, KEY_KEY_F));
+        KeyMap.push_back(SKeyMap(SDLK_F1,  KEY_F1));
+        KeyMap.push_back(SKeyMap(SDLK_F2,  KEY_F2));
+        KeyMap.push_back(SKeyMap(SDLK_F3,  KEY_F3));
+        KeyMap.push_back(SKeyMap(SDLK_F4,  KEY_F4));
+        KeyMap.push_back(SKeyMap(SDLK_F5,  KEY_F5));
+        KeyMap.push_back(SKeyMap(SDLK_F6,  KEY_F6));
+        KeyMap.push_back(SKeyMap(SDLK_F7,  KEY_F7));
+        KeyMap.push_back(SKeyMap(SDLK_F8,  KEY_F8));
+        KeyMap.push_back(SKeyMap(SDLK_F9,  KEY_F9));
+        KeyMap.push_back(SKeyMap(SDLK_F10, KEY_F10));
+        KeyMap.push_back(SKeyMap(SDLK_F11, KEY_F11));
+        KeyMap.push_back(SKeyMap(SDLK_F12, KEY_F12));
+        KeyMap.push_back(SKeyMap(SDLK_F13, KEY_F13));
+        KeyMap.push_back(SKeyMap(SDLK_F14, KEY_F14));
+        KeyMap.push_back(SKeyMap(SDLK_F15, KEY_F15));
+        KeyMap.push_back(SKeyMap(SDLK_F16, KEY_F16));
+        KeyMap.push_back(SKeyMap(SDLK_F17, KEY_F17));
+        KeyMap.push_back(SKeyMap(SDLK_F18, KEY_F18));
+        KeyMap.push_back(SKeyMap(SDLK_F19, KEY_F19));
+        KeyMap.push_back(SKeyMap(SDLK_F20, KEY_F20));
+        KeyMap.push_back(SKeyMap(SDLK_F21, KEY_F21));
+        KeyMap.push_back(SKeyMap(SDLK_F22, KEY_F22));
+        KeyMap.push_back(SKeyMap(SDLK_F23, KEY_F23));
+        KeyMap.push_back(SKeyMap(SDLK_F24, KEY_F24));
+        KeyMap.push_back(SKeyMap(SDLK_g, KEY_KEY_G));
+        KeyMap.push_back(SKeyMap(SDLK_h, KEY_KEY_H));
+        KeyMap.push_back(SKeyMap(SDLK_HELP, KEY_HELP));
+        KeyMap.push_back(SKeyMap(SDLK_HOME, KEY_HOME));
+        KeyMap.push_back(SKeyMap(SDLK_i, KEY_KEY_I));
+        KeyMap.push_back(SKeyMap(SDLK_INSERT, KEY_INSERT));
+        KeyMap.push_back(SKeyMap(SDLK_j, KEY_KEY_J));
+        KeyMap.push_back(SKeyMap(SDLK_k, KEY_KEY_K));
+        KeyMap.push_back(SKeyMap(SDLK_KP_0, KEY_NUMPAD0));
+        KeyMap.push_back(SKeyMap(SDLK_KP_00, KEY_NUMPAD0));
+        KeyMap.push_back(SKeyMap(SDLK_KP_000, KEY_NUMPAD0));
+        KeyMap.push_back(SKeyMap(SDLK_KP_1, KEY_NUMPAD1));
+        KeyMap.push_back(SKeyMap(SDLK_KP_2, KEY_NUMPAD2));
+        KeyMap.push_back(SKeyMap(SDLK_KP_3, KEY_NUMPAD3));
+        KeyMap.push_back(SKeyMap(SDLK_KP_4, KEY_NUMPAD4));
+        KeyMap.push_back(SKeyMap(SDLK_KP_5, KEY_NUMPAD5));
+        KeyMap.push_back(SKeyMap(SDLK_KP_6, KEY_NUMPAD6));
+        KeyMap.push_back(SKeyMap(SDLK_KP_7, KEY_NUMPAD7));
+        KeyMap.push_back(SKeyMap(SDLK_KP_8, KEY_NUMPAD8));
+        KeyMap.push_back(SKeyMap(SDLK_KP_9, KEY_NUMPAD9));
+        KeyMap.push_back(SKeyMap(SDLK_KP_A, KEY_KEY_A));
+        KeyMap.push_back(SKeyMap(SDLK_KP_B, KEY_KEY_B));
+        KeyMap.push_back(SKeyMap(SDLK_KP_BACKSPACE, KEY_BACK));
+        KeyMap.push_back(SKeyMap(SDLK_KP_C, KEY_KEY_C));
+        KeyMap.push_back(SKeyMap(SDLK_KP_CLEAR, KEY_CLEAR));
+        KeyMap.push_back(SKeyMap(SDLK_KP_D, KEY_KEY_D));
+        KeyMap.push_back(SKeyMap(SDLK_KP_DECIMAL, KEY_DECIMAL));
+        KeyMap.push_back(SKeyMap(SDLK_KP_DIVIDE, KEY_DIVIDE));
+        KeyMap.push_back(SKeyMap(SDLK_KP_E, KEY_KEY_E));
+        KeyMap.push_back(SKeyMap(SDLK_KP_ENTER, KEY_RETURN));
+        KeyMap.push_back(SKeyMap(SDLK_KP_F, KEY_KEY_F));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMADD, KEY_PLUS));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMCLEAR, KEY_CLEAR));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMDIVIDE, KEY_DIVIDE));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMMULTIPLY, KEY_MULTIPLY));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMSUBTRACT, KEY_MINUS));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MEMDIVIDE, KEY_DIVIDE));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MINUS, KEY_SUBTRACT));
+        KeyMap.push_back(SKeyMap(SDLK_KP_MULTIPLY, KEY_MULTIPLY));
+        KeyMap.push_back(SKeyMap(SDLK_KP_PLUS, KEY_ADD));
+        KeyMap.push_back(SKeyMap(SDLK_KP_SPACE, KEY_SPACE));
+        KeyMap.push_back(SKeyMap(SDLK_KP_TAB, KEY_TAB));
+        KeyMap.push_back(SKeyMap(SDLK_l, KEY_KEY_L));
+        KeyMap.push_back(SKeyMap(SDLK_LALT,  KEY_LMENU));
+        KeyMap.push_back(SKeyMap(SDLK_LCTRL,  KEY_LCONTROL));
+        KeyMap.push_back(SKeyMap(SDLK_LEFT, KEY_LEFT));
+        KeyMap.push_back(SKeyMap(SDLK_LGUI, KEY_LWIN));
+        KeyMap.push_back(SKeyMap(SDLK_LSHIFT, KEY_LSHIFT));
+        KeyMap.push_back(SKeyMap(SDLK_m, KEY_KEY_M));
+        KeyMap.push_back(SKeyMap(SDLK_MENU,  KEY_RMENU));
+        KeyMap.push_back(SKeyMap(SDLK_MINUS,  KEY_MINUS));
+        KeyMap.push_back(SKeyMap(SDLK_n, KEY_KEY_N));
+        KeyMap.push_back(SKeyMap(SDLK_NUMLOCKCLEAR, KEY_NUMLOCK));
+        KeyMap.push_back(SKeyMap(SDLK_o, KEY_KEY_O));
+        KeyMap.push_back(SKeyMap(SDLK_p, KEY_KEY_P));
+        KeyMap.push_back(SKeyMap(SDLK_PAGEDOWN, KEY_NEXT));
+        KeyMap.push_back(SKeyMap(SDLK_PAGEUP, KEY_PRIOR));
+        KeyMap.push_back(SKeyMap(SDLK_PAUSE, KEY_PAUSE));
+        KeyMap.push_back(SKeyMap(SDLK_PERIOD, KEY_PERIOD));
+        KeyMap.push_back(SKeyMap(SDLK_PLUS,   KEY_PLUS));
+        KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_SNAPSHOT));
+        KeyMap.push_back(SKeyMap(SDLK_q, KEY_KEY_Q));
+        KeyMap.push_back(SKeyMap(SDLK_r, KEY_KEY_R));
+        KeyMap.push_back(SKeyMap(SDLK_RALT,  KEY_RMENU));
+        KeyMap.push_back(SKeyMap(SDLK_RCTRL,  KEY_RCONTROL));
+        KeyMap.push_back(SKeyMap(SDLK_RETURN, KEY_RETURN));
+        KeyMap.push_back(SKeyMap(SDLK_RGUI, KEY_RWIN));
+        KeyMap.push_back(SKeyMap(SDLK_RIGHT, KEY_RIGHT));
+        KeyMap.push_back(SKeyMap(SDLK_RSHIFT, KEY_RSHIFT));
+        KeyMap.push_back(SKeyMap(SDLK_s, KEY_KEY_S));
+        KeyMap.push_back(SKeyMap(SDLK_SCROLLLOCK, KEY_SCROLL));
+    	KeyMap.push_back(SKeyMap(SDLK_SEPARATOR, KEY_SEPARATOR));
+    	KeyMap.push_back(SKeyMap(SDLK_SLASH, KEY_DIVIDE));
+    	KeyMap.push_back(SKeyMap(SDLK_SLEEP, KEY_SLEEP));
+        KeyMap.push_back(SKeyMap(SDLK_SPACE, KEY_SPACE));
+        KeyMap.push_back(SKeyMap(SDLK_t, KEY_KEY_T));
+        KeyMap.push_back(SKeyMap(SDLK_TAB, KEY_TAB));
+        KeyMap.push_back(SKeyMap(SDLK_u, KEY_KEY_U));
+        KeyMap.push_back(SKeyMap(SDLK_UP, KEY_UP));
+        KeyMap.push_back(SKeyMap(SDLK_v, KEY_KEY_V));
+        KeyMap.push_back(SKeyMap(SDLK_w, KEY_KEY_W));
+        KeyMap.push_back(SKeyMap(SDLK_x, KEY_KEY_X));
+        KeyMap.push_back(SKeyMap(SDLK_y, KEY_KEY_Y));
+        KeyMap.push_back(SKeyMap(SDLK_z, KEY_KEY_Z));
+
+        KeyMap.sort();
+    }
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
Index: source/Irrlicht/CIrrDeviceSDL2.h
===================================================================
--- source/Irrlicht/CIrrDeviceSDL2.h	(revision 0)
+++ source/Irrlicht/CIrrDeviceSDL2.h	(working copy)
@@ -0,0 +1,295 @@
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+// This device code is based on the original SDL device implementation
+// contributed by Shane Parker (sirshane).
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
+
+#ifndef __C_IRR_DEVICE_SDL2_H_INCLUDED__
+#define __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "IrrlichtDevice.h"
+#include "CIrrDeviceStub.h"
+#include "IImagePresenter.h"
+#include "ICursorControl.h"
+#include "IGUIElement.h"
+#include "EGUIElementTypes.h"
+#include "IGUIEnvironment.h"
+#include "os.h"
+
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_syswm.h>
+
+namespace irr
+{
+
+	class CIrrDeviceSDL2 : public CIrrDeviceStub, video::IImagePresenter
+	{
+        public:
+            //! constructor
+            CIrrDeviceSDL2(const SIrrlichtCreationParameters &param);
+
+            //! destructor
+            virtual ~CIrrDeviceSDL2();
+
+            //! runs the device. Returns false if device wants to be deleted
+            virtual bool run() _IRR_OVERRIDE_;
+
+            //! send the event to the right receiver
+            //virtual bool postEventFromUser(const SEvent& event) _IRR_OVERRIDE_;
+
+            //! Sets a new event receiver to receive events
+            virtual void setEventReceiver(IEventReceiver* receiver) _IRR_OVERRIDE_;
+
+            //! pause execution temporarily
+            virtual void yield() _IRR_OVERRIDE_;
+
+            //! pause execution for a specified time
+            virtual void sleep(u32 timeMs, bool pauseTimer) _IRR_OVERRIDE_;
+
+            //! sets the caption of the window
+            virtual void setWindowCaption(const wchar_t* text) _IRR_OVERRIDE_;
+
+            //! returns if window is active. if not, nothing need to be drawn
+            virtual bool isWindowActive() const _IRR_OVERRIDE_;
+
+            //! returns if window has focus.
+            bool isWindowFocused() const;
+
+            //! returns if window is minimized.
+            bool isWindowMinimized() const;
+
+            //! returns color format of the window.
+            video::ECOLOR_FORMAT getColorFormat() const;
+
+            //! presents a surface in the client area
+            virtual bool present(video::IImage* irrSurface, void* windowId = 0, core::recti* src = 0) _IRR_OVERRIDE_;
+
+            //! notifies the device that it should close itself
+            virtual void closeDevice() _IRR_OVERRIDE_;
+
+            //! \return Returns a pointer to a list with all video modes supported
+            virtual video::IVideoModeList* getVideoModeList() _IRR_OVERRIDE_;
+
+            //! Sets if the window should be resizable in windowed mode.
+            virtual void setResizable(bool resize = false) _IRR_OVERRIDE_;
+
+            //! Minimizes the window.
+            virtual void minimizeWindow() _IRR_OVERRIDE_;
+
+            //! Maximizes the window.
+            virtual void maximizeWindow() _IRR_OVERRIDE_;
+
+            //! Restores the window size.
+            virtual void restoreWindow() _IRR_OVERRIDE_;
+
+            //! Get the position of this window on screen
+            virtual core::position2di getWindowPosition() _IRR_OVERRIDE_;
+
+            //! Activate any joysticks, and generate events for them.
+            virtual bool activateJoysticks(core::array<SJoystickInfo> &joystickInfo) _IRR_OVERRIDE_;
+
+            //! Set the current Gamma Value for the Display
+            virtual bool setGammaRamp(f32 red, f32 green, f32 blue, f32 brightness, f32 contrast) _IRR_OVERRIDE_;
+
+            //! Get the current Gamma Value for the Display
+            virtual bool getGammaRamp(f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast) _IRR_OVERRIDE_;
+
+            //! Get the device type
+            virtual E_DEVICE_TYPE getType() const _IRR_OVERRIDE_
+            {
+                return EIDT_SDL2;
+            }
+
+        private:
+            //! Implementation of the linux cursor control
+            class CCursorControlSDL2 : public gui::ICursorControl
+            {
+                public:
+                    CCursorControlSDL2(CIrrDeviceSDL2* dev, SDL_Window* SDLWindow) :
+                        Device(dev), IsVisible(true), win(SDLWindow)
+                    {
+                    }
+
+                    //! Changes the visible state of the mouse cursor.
+                    virtual void setVisible(bool visible) _IRR_OVERRIDE_
+                    {
+                        IsVisible = visible;
+                        SDL_ShowCursor(IsVisible ? SDL_ENABLE : SDL_DISABLE);
+                    }
+
+                    //! Returns if the cursor is currently visible.
+                    virtual bool isVisible() const _IRR_OVERRIDE_
+                    {
+                        return IsVisible;
+                    }
+
+                    //! Sets the new position of the cursor.
+                    virtual void setPosition(const core::position2df &pos) _IRR_OVERRIDE_
+                    {
+                        setPosition(pos.X, pos.Y);
+                    }
+
+                    //! Sets the new position of the cursor.
+                    virtual void setPosition(f32 x, f32 y) _IRR_OVERRIDE_
+                    {
+                        setPosition(s32(x * Device->Width), s32(y * Device->Height));
+                    }
+
+                    //! Sets the new position of the cursor.
+                    virtual void setPosition(const core::position2di &pos) _IRR_OVERRIDE_
+                    {
+                        setPosition(pos.X, pos.Y);
+                    }
+
+                    //! Sets the new position of the cursor.
+                    virtual void setPosition(s32 x, s32 y) _IRR_OVERRIDE_
+                    {
+                        SDL_WarpMouseInWindow(win, x, y);
+                    }
+
+                    //! Returns the current position of the mouse cursor.
+                    virtual const core::position2di &getPosition() _IRR_OVERRIDE_
+                    {
+                        updateCursorPos();
+                        return CursorPos;
+                    }
+
+                    //! Returns the current position of the mouse cursor.
+                    virtual core::position2df getRelativePosition() _IRR_OVERRIDE_
+                    {
+                        updateCursorPos();
+                        return core::position2df(CursorPos.X / f32(Device->Width), CursorPos.Y / f32(Device->Height));
+                    }
+
+                    virtual void setReferenceRect(core::recti* rect = 0) _IRR_OVERRIDE_
+                    {
+                    }
+
+                private:
+                    void updateCursorPos()
+                    {
+                        CursorPos.X = Device->MouseX;
+                        CursorPos.Y = Device->MouseY;
+
+                        if(CursorPos.X < 0) CursorPos.X = 0;
+                        if(CursorPos.X > s32(Device->Width)) CursorPos.X = Device->Width;
+                        if(CursorPos.Y < 0) CursorPos.Y = 0;
+                        if(CursorPos.Y > s32(Device->Height)) CursorPos.Y = Device->Height;
+                    }
+
+                    CIrrDeviceSDL2* Device;
+                    core::position2di CursorPos;
+                    bool IsVisible;
+                    SDL_Window* win;
+            };
+
+            class SDL2EventReceiver : public IEventReceiver
+            {
+                public:
+                    SDL2EventReceiver() {}
+
+                    bool OnEvent(const SEvent& event)
+                    {
+                        if(actual && actual->OnEvent(event)) return true;
+                        #ifdef _IRR_COMPILE_WITH_GUI_
+                        if(event.EventType == EET_GUI_EVENT && event.GUIEvent.Caller->getType() == gui::EGUIET_EDIT_BOX)
+                        {
+                            /*! Show and hide the soft input keyboard when an edit-box get's the focus. */
+                            switch(event.GUIEvent.EventType)
+                            {
+                                case gui::EGET_ELEMENT_FOCUS_LOST:
+                                    {
+                                        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "EGUIET_EDIT_BOX && EGET_ELEMENT_FOCUS_LOST");
+                                        SDL_StopTextInput();
+                                    }
+                                    break;
+                                case gui::EGET_ELEMENT_FOCUSED:
+                                    {
+                                        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "EGUIET_EDIT_BOX && EGET_ELEMENT_FOCUSED");
+                                        SDL_StartTextInput();
+                                    }
+                                    break;
+                                case gui::EGET_EDITBOX_CHANGED:
+                                    {
+                                        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "EGUIET_EDIT_BOX && EGET_EDITBOX_CHANGED");
+                                    }
+                                    break;
+                                default:
+                                    {
+                                        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "EGUIET_EDIT_BOX unhandled %d", event.GUIEvent.EventType);
+                                    }
+                                    break;
+                            }
+                        }
+                        #endif // _IRR_COMPILE_WITH_GUI_
+                        return false;
+                    }
+
+                    IEventReceiver* actual;
+            };
+
+        private:
+            //! create the driver
+            void createDriver();
+
+            bool createWindow();
+
+            bool createRenderer();
+
+            void createKeyMap();
+
+            void updateWindowSize();
+
+            #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+            core::array<SDL_Joystick*> Joysticks;
+            core::array<SJoystickInfo>* joyinfo;
+            #endif
+
+            s32 MouseX, MouseY;
+            u32 MouseButtonStates;
+
+            u32 Width, Height;
+
+            bool Resizable;
+            bool WindowHasFocus;
+            bool WindowMinimized;
+
+            struct SKeyMap
+            {
+                SKeyMap() : SDLKey(SDLK_UNKNOWN), IrrKey(KEY_OEM_8) {}
+                SKeyMap(s32 sdlk, s32 irrk) : SDLKey(sdlk), IrrKey(irrk) {}
+
+                s32 SDLKey;
+                s32 IrrKey;
+
+                bool operator< (const SKeyMap &o) const
+                {
+                    return SDLKey < o.SDLKey;
+                }
+            };
+
+            core::array<SKeyMap> KeyMap;
+            SDL_SysWMinfo Info;
+            SDL_Window* window;
+            SDL_GLContext glContext;
+            SDL_Renderer* renderer;
+            int rendFlags, winFlags;
+
+            video::SExposedVideoData filler;
+
+            SDL2EventReceiver* sdlEventReceiver;
+	};
+
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+#endif // __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
Index: source/Irrlicht/CLogger.cpp
===================================================================
--- source/Irrlicht/CLogger.cpp	(revision 4940)
+++ source/Irrlicht/CLogger.cpp	(working copy)
@@ -4,6 +4,10 @@
 
 #include "CLogger.h"
 
+#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+#include <SDL2/SDL_log.h>
+#endif // defined
+
 namespace irr
 {
 
@@ -25,13 +29,32 @@
 	void CLogger::setLogLevel(ELOG_LEVEL ll)
 	{
 		LogLevel = ll;
+		#if defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+        switch (ll)
+        {
+            case ELL_DEBUG:
+                SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_DEBUG);
+                break;
+            case ELL_INFORMATION:
+                SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
+                break;
+            case ELL_WARNING:
+                SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_WARN);
+                break;
+            case ELL_ERROR:
+                SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_ERROR);
+                break;
+            default: // ELL_NONE
+                SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_CRITICAL);
+                break;
+        }
+        #endif // defined
 	}
 
 	//! Prints out a text into the log
 	void CLogger::log(const c8* text, ELOG_LEVEL ll)
 	{
-		if (ll < LogLevel)
-			return;
+		if(ll < LogLevel) return;
 
 		if (Receiver)
 		{
Index: source/Irrlicht/COGLES2Driver.cpp
===================================================================
--- source/Irrlicht/COGLES2Driver.cpp	(revision 4940)
+++ source/Irrlicht/COGLES2Driver.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2014 Patryk Nadrowski
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "COGLES2Driver.h"
 // needed here also because of the create methods' parameters
@@ -34,22 +38,11 @@
 {
 
 COGLES2Driver::COGLES2Driver(const SIrrlichtCreationParameters& params,
-			io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-            , IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-            , CIrrDeviceIPhone* device
-#endif
-            ) : CNullDriver(io, params.WindowSize), COGLES2ExtensionHandler(),
-	CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
-	Transformation3DChanged(true), AntiAlias(params.AntiAlias), OGLES2ShaderPath(params.OGLES2ShaderPath),
-	RenderTargetTexture(0), CurrentRendertargetSize(0, 0), ColorFormat(ECF_R8G8B8), BridgeCalls(0)
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-    , ContextManager(contextManager)
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-    , Device(device), ViewFramebuffer(0),
-	ViewRenderbuffer(0), ViewDepthRenderbuffer(0)
-#endif
+			io::IFileSystem* io, IContextManager* contextManager) :
+        CNullDriver(io, params.WindowSize), COGLES2ExtensionHandler(), CurrentRenderMode(ERM_NONE),
+        ResetRenderStates(true), Transformation3DChanged(true), AntiAlias(params.AntiAlias),
+        OGLES2ShaderPath(params.OGLES2ShaderPath), RenderTargetTexture(0), CurrentRendertargetSize(0, 0),
+        ColorFormat(ECF_R8G8B8), BridgeCalls(0), ContextManager(contextManager)
 	{
 #ifdef _DEBUG
 	setDebugName("COGLES2Driver");
@@ -56,9 +49,8 @@
 #endif
 
     core::dimension2d<u32> WindowSize(0, 0);
-
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-	if (!ContextManager)
+
+    if (!ContextManager)
 		return;
 
 	ContextManager->grab();
@@ -68,7 +60,25 @@
 	ContextManager->activateContext(ExposedData);
 
 	WindowSize = params.WindowSize;
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+
+	genericDriverInit(WindowSize, params.Stencilbuffer);
+}
+
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+COGLES2Driver::COGLES2Driver(const SIrrlichtCreationParameters& params,
+			io::IFileSystem* io, CIrrDeviceIPhone* device) : CNullDriver(io, params.WindowSize), COGLES2ExtensionHandler(),
+	CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
+	Transformation3DChanged(true), AntiAlias(params.AntiAlias), OGLES2ShaderPath(params.OGLES2ShaderPath),
+	RenderTargetTexture(0), CurrentRendertargetSize(0, 0), ColorFormat(ECF_R8G8B8), BridgeCalls(0)
+    , Device(device), ViewFramebuffer(0),
+	ViewRenderbuffer(0), ViewDepthRenderbuffer(0)
+	{
+#ifdef _DEBUG
+	setDebugName("COGLES2Driver");
+#endif
+
+    core::dimension2d<u32> WindowSize(0, 0);
+
 	glGenFramebuffers(1, &ViewFramebuffer);
 	glGenRenderbuffers(1, &ViewRenderbuffer);
 	glBindRenderbuffer(GL_RENDERBUFFER, ViewRenderbuffer);
@@ -98,10 +108,10 @@
 	WindowSize = core::dimension2d<u32>(backingWidth, backingHeight);
 	CNullDriver::ScreenSize = WindowSize;
 	CNullDriver::ViewPort = core::rect<s32>(core::position2d<s32>(0,0), core::dimension2di(WindowSize));
-#endif
 
 	genericDriverInit(WindowSize, params.Stencilbuffer);
-}
+}
+#endif
 
 COGLES2Driver::~COGLES2Driver()
 {
@@ -113,7 +123,7 @@
 
 	delete BridgeCalls;
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 	if (ContextManager)
 	{
 		ContextManager->destroyContext();
@@ -120,7 +130,7 @@
 		ContextManager->destroySurface();
 		ContextManager->drop();
 	}
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#else
 	if (0 != ViewFramebuffer)
 	{
 		glDeleteFramebuffers(1,&ViewFramebuffer);
@@ -454,10 +464,9 @@
 {
 	CNullDriver::endScene();
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-    if (ContextManager)
-		ContextManager->swapBuffers();
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+    if(ContextManager) ContextManager->swapBuffers();
+#else
     glFlush();
 	glBindRenderbuffer(GL_RENDERBUFFER, ViewRenderbuffer);
     Device->displayEnd();
@@ -3004,29 +3013,27 @@
 
 #ifndef _IRR_COMPILE_WITH_OGLES2_
 class IContextManager;
-#endif
+#endif
+
+IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager)
+{
+    #ifdef _IRR_COMPILE_WITH_OGLES2_
+    return new COGLES2Driver(params, io, contextManager);
+    #else
+    return NULL;
+    #endif
+}
+
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceIPhone* device)
+{
+    #ifdef _IRR_COMPILE_WITH_OGLES2_
+    return new COGLES2Driver(params, io, device);
+    #else
+    return NULL;
+    #endif
+}
+#endif // defined
 
-IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params,
-		io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-        , IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-        , CIrrDeviceIPhone* device
-#endif
-    )
-{
-#ifdef _IRR_COMPILE_WITH_OGLES2_
-	return new COGLES2Driver(params, io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-        , contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-        , device
-#endif
-    );
-#else
-	return 0;
-#endif //  _IRR_COMPILE_WITH_OGLES2_
-}
-
 } // end namespace
 } // end namespace
Index: source/Irrlicht/COGLES2Driver.h
===================================================================
--- source/Irrlicht/COGLES2Driver.h	(revision 4940)
+++ source/Irrlicht/COGLES2Driver.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2014 Patryk Nadrowski
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_OGLES2_DRIVER_H_INCLUDED__
 #define __C_OGLES2_DRIVER_H_INCLUDED__
@@ -50,14 +54,11 @@
 
 	public:
 		//! constructor
-		COGLES2Driver(const SIrrlichtCreationParameters& params,
-				io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-		, IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-		, CIrrDeviceIPhone* device
+		COGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager);
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+        //! IPhone constructor
+		COGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceIPhone* device);
 #endif
-		);
 
 		//! destructor
 		virtual ~COGLES2Driver();
@@ -516,7 +517,7 @@
 		GLuint ViewFramebuffer;
 		GLuint ViewRenderbuffer;
 		GLuint ViewDepthRenderbuffer;
-#elif defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
+#else
 		IContextManager* ContextManager;
 #endif
 	};
Index: source/Irrlicht/COGLES2ExtensionHandler.h
===================================================================
--- source/Irrlicht/COGLES2ExtensionHandler.h	(revision 4940)
+++ source/Irrlicht/COGLES2ExtensionHandler.h	(working copy)
@@ -2,7 +2,11 @@
 // Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt
 // and OpenGL ES driver implemented by Christian Stehno
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_OGLES2_EXTENSION_HANDLER_H_INCLUDED__
 #define __C_OGLES2_EXTENSION_HANDLER_H_INCLUDED__
@@ -11,25 +15,19 @@
 
 #ifdef _IRR_COMPILE_WITH_OGLES2_
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include "CEGLManager.h"
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#else
 #include "iOS/CIrrDeviceiOS.h"
-#endif
+#endif
 
 #if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include <OpenGLES/ES2/gl.h>
 #include <OpenGLES/ES2/glext.h>
-#elif defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#else
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
-#else
-#include <GLES2/gl2.h>
-typedef char GLchar;
-#if defined(_IRR_OGLES2_USE_EXTPOINTER_)
-#include "gles2-ext.h"
 #endif
-#endif
 
 #include "os.h"
 #include "EDriverFeatures.h"
Index: source/Irrlicht/COGLES2MaterialRenderer.h
===================================================================
--- source/Irrlicht/COGLES2MaterialRenderer.h	(revision 4940)
+++ source/Irrlicht/COGLES2MaterialRenderer.h	(working copy)
@@ -28,7 +28,7 @@
 
 namespace irr
 {
-namespace video  
+namespace video
 {
 
 class COGLES2Driver;
@@ -38,8 +38,8 @@
 public:
 
 	COGLES2MaterialRenderer(
-		COGLES2Driver* driver, 
-		s32& outMaterialTypeNr, 
+		COGLES2Driver* driver,
+		s32& outMaterialTypeNr,
 		const c8* vertexShaderProgram = 0,
 		const c8* pixelShaderProgram = 0,
 		IShaderConstantSetCallBack* callback = 0,
@@ -62,7 +62,7 @@
 	virtual s32 getRenderCapability() const;
 
 	virtual void setBasicRenderStates(const SMaterial& material, const SMaterial& lastMaterial, bool resetAllRenderstates);
-	
+
 	virtual s32 getVertexShaderConstantID(const c8* name);
 	virtual s32 getPixelShaderConstantID(const c8* name);
 	virtual void setVertexShaderConstant(const f32* data, s32 startRegister, s32 constantAmount=1);
@@ -85,7 +85,7 @@
 
 	bool createShader(GLenum shaderType, const char* shader);
 	bool linkProgram();
-	
+
 	COGLES2Driver* Driver;
 	IShaderConstantSetCallBack* CallBack;
 
Index: source/Irrlicht/COGLES2Texture.h
===================================================================
--- source/Irrlicht/COGLES2Texture.h	(revision 4940)
+++ source/Irrlicht/COGLES2Texture.h	(working copy)
@@ -7,7 +7,7 @@
 
 #include "IrrCompileConfig.h"
 
-#ifdef _IRR_COMPILE_WITH_OGLES2_
+#ifdef _IRR_COMPILE_WITH_OGLES2_
 
 #if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include <OpenGLES/ES2/gl.h>
Index: source/Irrlicht/COGLESDriver.cpp
===================================================================
--- source/Irrlicht/COGLESDriver.cpp	(revision 4940)
+++ source/Irrlicht/COGLESDriver.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2008 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in irrlicht.h
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "COGLESDriver.h"
 #include "SIrrCreationParameters.h" // for createDriver function
@@ -14,10 +18,6 @@
 #include "CImage.h"
 #include "os.h"
 
-#ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
-#include <SDL/SDL.h>
-#endif
-
 namespace irr
 {
 namespace video
@@ -24,22 +24,10 @@
 {
 
 COGLES1Driver::COGLES1Driver(const SIrrlichtCreationParameters& params,
-            io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-            , IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-            , CIrrDeviceIPhone* device
-#endif
-            ) : CNullDriver(io, params.WindowSize), COGLES1ExtensionHandler(),
+            io::IFileSystem* io, IContextManager* contextManager) : CNullDriver(io, params.WindowSize), COGLES1ExtensionHandler(),
 	CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
 	Transformation3DChanged(true), AntiAlias(params.AntiAlias),
-	RenderTargetTexture(0), CurrentRendertargetSize(0,0), ColorFormat(ECF_R8G8B8), BridgeCalls(0)
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-    , ContextManager(contextManager)
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-    , Device(device), ViewFramebuffer(0),
-	ViewRenderbuffer(0), ViewDepthRenderbuffer(0)
-#endif
+	RenderTargetTexture(0), CurrentRendertargetSize(0,0), ColorFormat(ECF_R8G8B8), BridgeCalls(0), ContextManager(contextManager)
 {
 #ifdef _DEBUG
 	setDebugName("COGLESDriver");
@@ -46,9 +34,7 @@
 #endif
 
     core::dimension2d<u32> WindowSize(0, 0);
-
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-	if (!ContextManager)
+    if (!ContextManager)
 		return;
 
 	ContextManager->grab();
@@ -58,7 +44,24 @@
 	ContextManager->activateContext(ExposedData);
 
 	WindowSize = params.WindowSize;
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+
+    genericDriverInit(WindowSize, params.Stencilbuffer);
+}
+
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+COGLES1Driver::COGLES1Driver(const SIrrlichtCreationParameters& params,
+            io::IFileSystem* io, CIrrDeviceIPhone* device) : CNullDriver(io, params.WindowSize), COGLES1ExtensionHandler(),
+	CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
+	Transformation3DChanged(true), AntiAlias(params.AntiAlias),
+	RenderTargetTexture(0), CurrentRendertargetSize(0,0), ColorFormat(ECF_R8G8B8), BridgeCalls(0), Device(device), ViewFramebuffer(0),
+	ViewRenderbuffer(0), ViewDepthRenderbuffer(0)
+{
+#ifdef _DEBUG
+	setDebugName("COGLESDriver");
+#endif
+
+    core::dimension2d<u32> WindowSize(0, 0);
+
 	glGenFramebuffersOES(1, &ViewFramebuffer);
 	glGenRenderbuffersOES(1, &ViewRenderbuffer);
 	glBindRenderbufferOES(GL_RENDERBUFFER_OES, ViewRenderbuffer);
@@ -88,10 +91,10 @@
     WindowSize = core::dimension2d<u32>(backingWidth, backingHeight);
     CNullDriver::ScreenSize = WindowSize;
     CNullDriver::ViewPort = core::rect<s32>(core::position2d<s32>(0,0), core::dimension2di(WindowSize));
-#endif
 
     genericDriverInit(WindowSize, params.Stencilbuffer);
-}
+}
+#endif // defined
 
 COGLES1Driver::~COGLES1Driver()
 {
@@ -102,7 +105,7 @@
 
 	delete BridgeCalls;
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 	if (ContextManager)
 	{
 		ContextManager->destroyContext();
@@ -109,7 +112,7 @@
 		ContextManager->destroySurface();
 		ContextManager->drop();
 	}
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#else
 	if (0 != ViewFramebuffer)
 	{
 		extGlDeleteFramebuffers(1,&ViewFramebuffer);
@@ -265,9 +268,9 @@
 {
 	CNullDriver::endScene();
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-    ContextManager->swapBuffers();
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+    if(ContextManager) ContextManager->swapBuffers();
+#else
     glFlush();
 	glBindRenderbufferOES(GL_RENDERBUFFER_OES, ViewRenderbuffer);
     Device->displayEnd();
@@ -3234,27 +3237,25 @@
 class IContextManager;
 #endif
 
-IVideoDriver* createOGLES1Driver(const SIrrlichtCreationParameters& params,
-		io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-        , IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-        , CIrrDeviceIPhone* device
-#endif
-    )
+IVideoDriver* createOGLES1Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager)
 {
-#ifdef _IRR_COMPILE_WITH_OGLES1_
-	return new COGLES1Driver(params, io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-        , contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-        , device
-#endif
-    );
-#else
+    #ifdef _IRR_COMPILE_WITH_OGLES1_
+	return new COGLES1Driver(params, io, contextManager);
+    #else
 	return 0;
-#endif //  _IRR_COMPILE_WITH_OGLES1_
+    #endif //  _IRR_COMPILE_WITH_OGLES1_
 }
+
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+IVideoDriver* createOGLES1Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceIPhone* device)
+{
+    #ifdef _IRR_COMPILE_WITH_OGLES1_
+	return new COGLES1Driver(params, io, device);
+    #else
+	return 0;
+    #endif //  _IRR_COMPILE_WITH_OGLES1_
+}
+#endif // defined
 
 } // end namespace
 } // end namespace
Index: source/Irrlicht/COGLESDriver.h
===================================================================
--- source/Irrlicht/COGLESDriver.h	(revision 4940)
+++ source/Irrlicht/COGLESDriver.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2008 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_OGLES_DRIVER_H_INCLUDED__
 #define __C_OGLES_DRIVER_H_INCLUDED__
@@ -35,14 +39,11 @@
 		friend class COGLES1Texture;
 	public:
 		//! constructor
-		COGLES1Driver(const SIrrlichtCreationParameters& params,
-				io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
-                , IContextManager* contextManager
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
-                , CIrrDeviceIPhone* device
+		COGLES1Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager);
+#if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+        //! IPhone constructor
+        COGLES1Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceIPhone* device);
 #endif
-                );
 
 		//! destructor
 		virtual ~COGLES1Driver();
@@ -449,7 +450,7 @@
 		GLuint ViewFramebuffer;
 		GLuint ViewRenderbuffer;
 		GLuint ViewDepthRenderbuffer;
-#elif defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_FB_DEVICE_)
+#else
         IContextManager* ContextManager;
 #endif
 	};
Index: source/Irrlicht/COGLESExtensionHandler.h
===================================================================
--- source/Irrlicht/COGLESExtensionHandler.h	(revision 4940)
+++ source/Irrlicht/COGLESExtensionHandler.h	(working copy)
@@ -1,7 +1,11 @@
 // Copyright (C) 2008 Christian Stehno
 // Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in Irrlicht.h
+// For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_OGLES_EXTENSION_HANDLER_H_INCLUDED__
 #define __C_OGLES_EXTENSION_HANDLER_H_INCLUDED__
@@ -10,25 +14,25 @@
 
 #ifdef _IRR_COMPILE_WITH_OGLES1_
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if !defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include "CEGLManager.h"
-#elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
+#else
 #include "iOS/CIrrDeviceiOS.h"
-#endif
+#endif
 
 #if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include <OpenGLES/ES1/gl.h>
 #include <OpenGLES/ES1/glext.h>
-#elif defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#else
 #include <GLES/gl.h>
 #include <GLES/glext.h>
-#else
-#include <GLES/gl.h>
-typedef char GLchar;
-#if defined(_IRR_OGLES1_USE_EXTPOINTER_)
-#include "gles-ext.h"
+//#else
+//#include <GLES/gl.h>
+//typedef char GLchar;
+//#if defined(_IRR_OGLES1_USE_EXTPOINTER_)
+//#include "gles-ext.h"
+//#endif
 #endif
-#endif
 
 #include "os.h"
 #include "EDriverFeatures.h"
Index: source/Irrlicht/COGLESTexture.h
===================================================================
--- source/Irrlicht/COGLESTexture.h	(revision 4940)
+++ source/Irrlicht/COGLESTexture.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2008 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in irrlicht.h
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_OGLES1_TEXTURE_H_INCLUDED__
 #define __C_OGLES1_TEXTURE_H_INCLUDED__
@@ -9,16 +13,16 @@
 #include "IImage.h"
 
 #include "IrrCompileConfig.h"
-#if defined(_IRR_COMPILE_WITH_OGLES1_)
+#if defined(_IRR_COMPILE_WITH_OGLES1_)
 
 #if defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 #include <OpenGLES/ES1/gl.h>
 #include <OpenGLES/ES1/glext.h>
-#elif defined(_IRR_ANDROID_PLATFORM_)
+#else
 #include <GLES/gl.h>
 #include <GLES/glext.h>
-#else
-#include <GLES/egl.h>
+//#else
+//#include <GLES/egl.h>
 #endif
 
 namespace irr
@@ -90,7 +94,7 @@
 
 	//! get the desired color format based on texture creation flags and the input format.
 	ECOLOR_FORMAT getBestColorFormat(ECOLOR_FORMAT format);
-    
+
     //! Get the OpenGL color format parameters based on the given Irrlicht color format
 	void getFormatParameters(ECOLOR_FORMAT format, GLint& internalFormat, GLint& filtering,
 		GLenum& pixelFormat, GLenum& type, void(*&convert)(const void*, s32, void*));
Index: source/Irrlicht/COSOperator.cpp
===================================================================
--- source/Irrlicht/COSOperator.cpp	(revision 4940)
+++ source/Irrlicht/COSOperator.cpp	(working copy)
@@ -1,23 +1,27 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "COSOperator.h"
 
 #ifdef _IRR_WINDOWS_API_
-#ifndef _IRR_XBOX_PLATFORM_
-#include <windows.h>
-#endif
+    #ifndef _IRR_XBOX_PLATFORM_
+        #include <windows.h>
+    #endif
 #else
-#include <string.h>
-#include <unistd.h>
-#ifndef _IRR_SOLARIS_PLATFORM_
-#ifndef _IRR_ANDROID_PLATFORM_
-#include <sys/types.h>
-#include <sys/sysctl.h>
+    #include <string.h>
+    #include <unistd.h>
+    #ifndef _IRR_SOLARIS_PLATFORM_
+        #ifndef _IRR_ANDROID_PLATFORM_
+            #include <sys/types.h>
+            #include <linux/sysctl.h>
+        #endif
+    #endif
 #endif
-#endif
-#endif
 
 #if defined(_IRR_COMPILE_WITH_X11_DEVICE_)
 #include "CIrrDeviceLinux.h"
Index: source/Irrlicht/COpenGLDriver.cpp
===================================================================
--- source/Irrlicht/COpenGLDriver.cpp	(revision 4940)
+++ source/Irrlicht/COpenGLDriver.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "COpenGLDriver.h"
 // needed here also because of the create methods' parameters
@@ -22,6 +26,9 @@
 #ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
 #include <SDL/SDL.h>
 #endif
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include <SDL2/SDL.h>
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
 
 namespace irr
 {
@@ -155,6 +162,35 @@
 
 
 // -----------------------------------------------------------------------
+// SDL2 CONSTRUCTOR
+// -----------------------------------------------------------------------
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+//! SDL2 constructor and init code
+COpenGLDriver::COpenGLDriver(const SIrrlichtCreationParameters& params,
+		io::IFileSystem* io, CIrrDeviceSDL2* device)
+    : CNullDriver(io, params.WindowSize), COpenGLExtensionHandler(),
+	CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
+	Transformation3DChanged(true), AntiAlias(params.AntiAlias),
+	RenderTargetTexture(0), CurrentRendertargetSize(0,0),
+	ColorFormat(ECF_R8G8B8), FixedPipelineState(EOFPS_ENABLE),
+	CurrentTarget(ERT_FRAME_BUFFER), Params(params), ContextManager(0),
+	BridgeCalls(0), SDL2Device(device), DeviceType(EIDT_SDL2)
+{
+	#ifdef _DEBUG
+	setDebugName("COpenGLDriver");
+	#endif
+
+	#ifdef _IRR_COMPILE_WITH_CG_
+	CgContext = 0;
+	#endif
+
+	genericDriverInit();
+}
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+
+// -----------------------------------------------------------------------
 // SDL CONSTRUCTOR
 // -----------------------------------------------------------------------
 #ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
@@ -397,38 +433,33 @@
 
 	glFlush();
 
-#ifdef _IRR_COMPILE_WITH_WINDOWS_DEVICE_
-	if (DeviceType == EIDT_WIN32)
+	switch(DeviceType)
 	{
-		return ContextManager->swapBuffers();
+	    #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+        case EIDT_SDL2:
+            SDL_GL_SwapWindow((SDL_Window*)Params.WindowId);
+            return true;
+        #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        #ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
+        case EIDT_SDL:
+            SDL_GL_SwapBuffers();
+            return true;
+        #endif // _IRR_COMPILE_WITH_SDL_DEVICE_
+        #ifdef _IRR_COMPILE_WITH_WINDOWS_DEVICE_
+        case EIDT_WIN32:
+            return ContextManager->swapBuffers();
+        #endif // _IRR_COMPILE_WITH_WINDOWS_DEVICE_
+        #ifdef _IRR_COMPILE_WITH_X11_DEVICE_
+        case EIDT_X11:
+            return ContextManager->swapBuffers();
+        #endif // _IRR_COMPILE_WITH_X11_DEVICE_
+        #ifdef _IRR_COMPILE_WITH_OSX_DEVICE_
+        case EIDT_OSX:
+            return ContextManager->swapBuffers();
+        #endif // _IRR_COMPILE_WITH_OSX_DEVICE_
+        default: // todo: console device present
+            return false;
 	}
-#endif
-
-#ifdef _IRR_COMPILE_WITH_X11_DEVICE_
-	if (DeviceType == EIDT_X11)
-	{
-		return ContextManager->swapBuffers();
-	}
-#endif
-
-#ifdef _IRR_COMPILE_WITH_OSX_DEVICE_
-	if (DeviceType == EIDT_OSX)
-	{
-		return ContextManager->swapBuffers();
-	}
-#endif
-
-#ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
-	if (DeviceType == EIDT_SDL)
-	{
-		SDL_GL_SwapBuffers();
-		return true;
-	}
-#endif
-
-	// todo: console device present
-
-	return false;
 }
 
 
@@ -469,9 +500,8 @@
 		const SExposedVideoData& videoData, core::rect<s32>* sourceRect)
 {
 	CNullDriver::beginScene(backBuffer, zBuffer, color, videoData, sourceRect);
-	ContextManager->activateContext(videoData);
-
-#if defined(_IRR_COMPILE_WITH_SDL_DEVICE_)
+	if(DeviceType != EIDT_SDL2) ContextManager->activateContext(videoData);
+    #if defined(_IRR_COMPILE_WITH_SDL_DEVICE_)
 	if (DeviceType == EIDT_SDL)
 	{
 		// todo: SDL sets glFrontFace(GL_CCW) after driver creation,
@@ -478,7 +508,7 @@
 		// it would be better if this was fixed elsewhere.
 		glFrontFace(GL_CW);
 	}
-#endif
+    #endif
 
 	clearBuffers(backBuffer, zBuffer, false, color);
 	return true;
@@ -3374,7 +3404,7 @@
 
 	if (vp.getHeight() > 0 && vp.getWidth() > 0)
 		BridgeCalls->setViewport(vp.UpperLeftCorner.X, getCurrentRenderTargetSize().Height - vp.UpperLeftCorner.Y - vp.getHeight(), vp.getWidth(), vp.getHeight());
-	
+
 	ViewPort = vp;
 }
 
@@ -4692,11 +4722,11 @@
 	glDisableClientState(GL_NORMAL_ARRAY);
 	glDisableClientState(GL_COLOR_ARRAY);
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-	
+
 	const core::dimension2d<u32> ScreenSize = Driver->getScreenSize();
 	ViewportWidth = ScreenSize.Width;
 	ViewportHeight = ScreenSize.Height;
-	glViewport(ViewportX, ViewportY, ViewportWidth, ViewportHeight);	
+	glViewport(ViewportX, ViewportY, ViewportWidth, ViewportHeight);
 }
 
 COpenGLCallBridge::~COpenGLCallBridge()
@@ -5130,6 +5160,22 @@
 
 
 // -----------------------------------
+// SDL2 VERSION
+// -----------------------------------
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+IVideoDriver* createOpenGLDriver(const SIrrlichtCreationParameters& params,
+		io::IFileSystem* io, CIrrDeviceSDL2* device)
+{
+#ifdef _IRR_COMPILE_WITH_OPENGL_
+	return new COpenGLDriver(params, io, device);
+#else
+	return 0;
+#endif //  _IRR_COMPILE_WITH_OPENGL_
+}
+#endif // _IRR_COMPILE_WITH_SDL_DEVICE_
+
+
+// -----------------------------------
 // SDL VERSION
 // -----------------------------------
 #ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
Index: source/Irrlicht/COpenGLDriver.h
===================================================================
--- source/Irrlicht/COpenGLDriver.h	(revision 4940)
+++ source/Irrlicht/COpenGLDriver.h	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in Irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_VIDEO_OPEN_GL_H_INCLUDED__
 #define __C_VIDEO_OPEN_GL_H_INCLUDED__
@@ -13,6 +17,7 @@
 {
 	class CIrrDeviceWin32;
 	class CIrrDeviceLinux;
+	class CIrrDeviceSDL2;
 	class CIrrDeviceSDL;
 	class CIrrDeviceMacOSX;
 }
@@ -63,6 +68,10 @@
 		bool initDriver(CIrrDeviceLinux* device);
 		#endif
 
+		#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+		COpenGLDriver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceSDL2* device);
+		#endif
+
 		#ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
 		COpenGLDriver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, CIrrDeviceSDL* device);
 		#endif
@@ -615,6 +624,9 @@
 		S3DVertex Quad2DVertices[4];
 		static const u16 Quad2DIndices[4];
 
+		#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+			CIrrDeviceSDL2* SDL2Device;
+		#endif
 		#ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
 			CIrrDeviceSDL *SDLDevice;
 		#endif
Index: source/Irrlicht/CReadFile.cpp
===================================================================
--- source/Irrlicht/CReadFile.cpp	(revision 4940)
+++ source/Irrlicht/CReadFile.cpp	(working copy)
@@ -1,113 +1,125 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "CReadFile.h"
 
 namespace irr
 {
-namespace io
-{
+    namespace io
+    {
+        CReadFile::CReadFile(const io::path& fileName) : File(NULL), FileSize(0), Filename(fileName)
+        {
+            #ifdef _DEBUG
+            setDebugName("CReadFile");
+            #endif
+            openFile();
+        }
 
+        CReadFile::~CReadFile()
+        {
+            if(File)
+            {
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                SDL_RWclose(File);
+                #else
+                fclose(File);
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+            }
+        }
 
-CReadFile::CReadFile(const io::path& fileName)
-: File(0), FileSize(0), Filename(fileName)
-{
-	#ifdef _DEBUG
-	setDebugName("CReadFile");
-	#endif
+        //! returns how much was read
+        s32 CReadFile::read(void* buffer, u32 sizeToRead)
+        {
+            if(!isOpen()) return 0;
 
-	openFile();
-}
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return (s32)SDL_RWread(File, buffer, 1, sizeToRead);
+            #else
+            return (s32)fread(buffer, 1, sizeToRead, File);
+            #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        }
 
+        //! changes position in file, returns true if successful
+        //! if relativeMovement==true, the pos is changed relative to current pos,
+        //! otherwise from begin of file
+        bool CReadFile::seek(long finalPos, bool relativeMovement)
+        {
+            if(!isOpen()) return false;
 
-CReadFile::~CReadFile()
-{
-	if (File)
-		fclose(File);
-}
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return SDL_RWseek(File, finalPos, relativeMovement ? RW_SEEK_CUR : RW_SEEK_SET) >= 0;
+            #else
+            return fseek(File, finalPos, relativeMovement ? SEEK_CUR : SEEK_SET) == 0;
+            #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        }
 
+        //! returns size of file
+        long CReadFile::getSize() const
+        {
+            return FileSize;
+        }
 
-//! returns how much was read
-s32 CReadFile::read(void* buffer, u32 sizeToRead)
-{
-	if (!isOpen())
-		return 0;
+        //! returns where in the file we are.
+        long CReadFile::getPos() const
+        {
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return (long)SDL_RWtell(File);
+            #else
+            return ftell(File);
+            #endif
+        }
 
-	return (s32)fread(buffer, 1, sizeToRead, File);
-}
+        //! opens the file
+        void CReadFile::openFile()
+        {
+            // bugfix posted by rt
+            if(Filename.size() == 0) return;
 
+            #if defined(_IRR_WCHAR_FILESYSTEM)
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                File = SDL_RWFromFile(Filename.c_str(), L"rb");
+                #else
+                File = _wfopen(Filename.c_str(), L"rb");
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+            #else
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                File = SDL_RWFromFile(Filename.c_str(), "rb");
+                #else
+                File = fopen(Filename.c_str(), "rb");
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+            #endif
 
-//! changes position in file, returns true if successful
-//! if relativeMovement==true, the pos is changed relative to current pos,
-//! otherwise from begin of file
-bool CReadFile::seek(long finalPos, bool relativeMovement)
-{
-	if (!isOpen())
-		return false;
+            if(File)
+            {
+                // get FileSize
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                SDL_RWseek(File, 0, RW_SEEK_END);
+                #else
+                fseek(File, 0, SEEK_END);
+                #endif
+                FileSize = getPos();
+                seek(0, false);
+            }
+        }
 
-	return fseek(File, finalPos, relativeMovement ? SEEK_CUR : SEEK_SET) == 0;
-}
+        //! returns name of file
+        const io::path& CReadFile::getFileName() const
+        {
+            return Filename;
+        }
 
+        IReadFile* CReadFile::createReadFile(const io::path& fileName)
+        {
+            CReadFile* file = new CReadFile(fileName);
+            if(file->isOpen()) return file;
 
-//! returns size of file
-long CReadFile::getSize() const
-{
-	return FileSize;
-}
-
-
-//! returns where in the file we are.
-long CReadFile::getPos() const
-{
-	return ftell(File);
-}
-
-
-//! opens the file
-void CReadFile::openFile()
-{
-	if (Filename.size() == 0) // bugfix posted by rt
-	{
-		File = 0;
-		return;
-	}
-
-#if defined ( _IRR_WCHAR_FILESYSTEM )
-	File = _wfopen(Filename.c_str(), L"rb");
-#else
-	File = fopen(Filename.c_str(), "rb");
-#endif
-
-	if (File)
-	{
-		// get FileSize
-
-		fseek(File, 0, SEEK_END);
-		FileSize = getPos();
-		fseek(File, 0, SEEK_SET);
-	}
-}
-
-
-//! returns name of file
-const io::path& CReadFile::getFileName() const
-{
-	return Filename;
-}
-
-
-IReadFile* CReadFile::createReadFile(const io::path& fileName)
-{
-	CReadFile* file = new CReadFile(fileName);
-	if (file->isOpen())
-		return file;
-
-	file->drop();
-	return 0;
-}
-
-
-} // end namespace io
+            file->drop();
+            return NULL;
+        }
+    } // end namespace io
 } // end namespace irr
-
Index: source/Irrlicht/CReadFile.h
===================================================================
--- source/Irrlicht/CReadFile.h	(revision 4940)
+++ source/Irrlicht/CReadFile.h	(working copy)
@@ -1,11 +1,20 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_READ_FILE_H_INCLUDED__
 #define __C_READ_FILE_H_INCLUDED__
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_rwops.h>
+#else
 #include <stdio.h>
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
 #include "IReadFile.h"
 #include "irrString.h"
 
@@ -55,7 +64,11 @@
 		//! opens the file
 		void openFile();
 
+		#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+		SDL_RWops* File;
+		#else
 		FILE* File;
+		#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
 		long FileSize;
 		io::path Filename;
 	};
Index: source/Irrlicht/CWriteFile.cpp
===================================================================
--- source/Irrlicht/CWriteFile.cpp	(revision 4940)
+++ source/Irrlicht/CWriteFile.cpp	(working copy)
@@ -1,123 +1,126 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "CWriteFile.h"
-#include <stdio.h>
 
 namespace irr
 {
-namespace io
-{
+    namespace io
+    {
+        CWriteFile::CWriteFile(const io::path& fileName, bool append) : File(NULL), FileSize(0)
+        {
+            #ifdef _DEBUG
+            setDebugName("CWriteFile");
+            #endif
 
+            Filename = fileName;
+            openFile(append);
+        }
 
-CWriteFile::CWriteFile(const io::path& fileName, bool append)
-: FileSize(0)
-{
-	#ifdef _DEBUG
-	setDebugName("CWriteFile");
-	#endif
+        CWriteFile::~CWriteFile()
+        {
+            if(File)
+            {
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                SDL_RWclose(File);
+                #else
+                fclose(File);
+                #endif
+            }
+        }
 
-	Filename = fileName;
-	openFile(append);
-}
+        //! returns if file is open
+        inline bool CWriteFile::isOpen() const
+        {
+            return File != NULL;
+        }
 
+        //! returns how much was read
+        s32 CWriteFile::write(const void* buffer, u32 sizeToWrite)
+        {
+            if(!isOpen()) return NULL;
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return (s32)SDL_RWwrite(File, buffer, 1, sizeToWrite);
+            #else
+            return (s32)fwrite(buffer, 1, sizeToWrite, File);
+            #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        }
 
+        //! changes position in file, returns true if successful
+        //! if relativeMovement==true, the pos is changed relative to current pos,
+        //! otherwise from begin of file
+        bool CWriteFile::seek(long finalPos, bool relativeMovement)
+        {
+            if(!isOpen()) return false;
 
-CWriteFile::~CWriteFile()
-{
-	if (File)
-		fclose(File);
-}
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return SDL_RWseek(File, finalPos, relativeMovement ? RW_SEEK_CUR : RW_SEEK_SET) == 0;
+            #else
+            return fseek(File, finalPos, relativeMovement ? SEEK_CUR : SEEK_SET) == 0;
+            #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        }
 
+        //! returns where in the file we are.
+        long CWriteFile::getPos() const
+        {
+            #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+            return (long)SDL_RWtell(File);
+            #else
+            return ftell(File);
+            #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+        }
 
+        //! opens the file
+        void CWriteFile::openFile(bool append)
+        {
+            // bugfix posted by rt
+            if(Filename.size() == 0) return;
 
-//! returns if file is open
-inline bool CWriteFile::isOpen() const
-{
-	return File != 0;
-}
+            #if defined(_IRR_WCHAR_FILESYSTEM)
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                File = SDL_RWFromFile(Filename.c_str(), append ? L"ab" : L"wb");
+                #else
+                File = _wfopen(Filename.c_str(), append ? L"ab" : L"wb");
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+            #else
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                File = SDL_RWFromFile(Filename.c_str(), append ? "ab" : "wb");
+                #else
+                File = fopen(Filename.c_str(), append ? "ab" : "wb");
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+            #endif
 
+            if(File)
+            {
+                // get FileSize
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                SDL_RWseek(File, 0, RW_SEEK_END);
+                #else
+                fseek(File, 0, SEEK_END);
+                #endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+                FileSize = getPos();
+                seek(0, false);
+            }
+        }
 
+        //! returns name of file
+        const io::path& CWriteFile::getFileName() const
+        {
+            return Filename;
+        }
 
-//! returns how much was read
-s32 CWriteFile::write(const void* buffer, u32 sizeToWrite)
-{
-	if (!isOpen())
-		return 0;
+        IWriteFile* CWriteFile::createWriteFile(const io::path& fileName, bool append)
+        {
+            CWriteFile* file = new CWriteFile(fileName, append);
+            if(file->isOpen()) return file;
 
-	return (s32)fwrite(buffer, 1, sizeToWrite, File);
-}
-
-
-
-//! changes position in file, returns true if successful
-//! if relativeMovement==true, the pos is changed relative to current pos,
-//! otherwise from begin of file
-bool CWriteFile::seek(long finalPos, bool relativeMovement)
-{
-	if (!isOpen())
-		return false;
-
-	return fseek(File, finalPos, relativeMovement ? SEEK_CUR : SEEK_SET) == 0;
-}
-
-
-
-//! returns where in the file we are.
-long CWriteFile::getPos() const
-{
-	return ftell(File);
-}
-
-
-
-//! opens the file
-void CWriteFile::openFile(bool append)
-{
-	if (Filename.size() == 0)
-	{
-		File = 0;
-		return;
-	}
-
-#if defined(_IRR_WCHAR_FILESYSTEM)
-	File = _wfopen(Filename.c_str(), append ? L"ab" : L"wb");
-#else
-	File = fopen(Filename.c_str(), append ? "ab" : "wb");
-#endif
-
-	if (File)
-	{
-		// get FileSize
-
-		fseek(File, 0, SEEK_END);
-		FileSize = ftell(File);
-		fseek(File, 0, SEEK_SET);
-	}
-}
-
-
-
-//! returns name of file
-const io::path& CWriteFile::getFileName() const
-{
-	return Filename;
-}
-
-
-
-IWriteFile* CWriteFile::createWriteFile(const io::path& fileName, bool append)
-{
-	CWriteFile* file = new CWriteFile(fileName, append);
-	if (file->isOpen())
-		return file;
-
-	file->drop();
-	return 0;
-}
-
-
-} // end namespace io
+            file->drop();
+            return NULL;
+        }
+    } // end namespace io
 } // end namespace irr
-
Index: source/Irrlicht/CWriteFile.h
===================================================================
--- source/Irrlicht/CWriteFile.h	(revision 4940)
+++ source/Irrlicht/CWriteFile.h	(working copy)
@@ -1,61 +1,68 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #ifndef __C_WRITE_FILE_H_INCLUDED__
 #define __C_WRITE_FILE_H_INCLUDED__
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_rwops.h>
+#else
 #include <stdio.h>
+#endif // __C_WRITE_FILE_H_INCLUDED__
 #include "IWriteFile.h"
 #include "irrString.h"
 
 namespace irr
 {
+    namespace io
+    {
+        /*!
+            Class for writing a real file to disk.
+        */
+        class CWriteFile : public IWriteFile
+        {
+            public:
+                CWriteFile(const io::path& fileName, bool append);
 
-namespace io
-{
+                virtual ~CWriteFile();
 
-	/*!
-		Class for writing a real file to disk.
-	*/
-	class CWriteFile : public IWriteFile
-	{
-	public:
+                //! Reads an amount of bytes from the file.
+                virtual s32 write(const void* buffer, u32 sizeToWrite) _IRR_OVERRIDE_;
 
-		CWriteFile(const io::path& fileName, bool append);
+                //! Changes position in file, returns true if successful.
+                virtual bool seek(long finalPos, bool relativeMovement = false) _IRR_OVERRIDE_;
 
-		virtual ~CWriteFile();
+                //! Returns the current position in the file.
+                virtual long getPos() const _IRR_OVERRIDE_;
 
-		//! Reads an amount of bytes from the file.
-		virtual s32 write(const void* buffer, u32 sizeToWrite) _IRR_OVERRIDE_;
+                //! Returns name of file.
+                virtual const io::path& getFileName() const _IRR_OVERRIDE_;
 
-		//! Changes position in file, returns true if successful.
-		virtual bool seek(long finalPos, bool relativeMovement = false) _IRR_OVERRIDE_;
+                //! returns if file is open
+                bool isOpen() const;
 
-		//! Returns the current position in the file.
-		virtual long getPos() const _IRR_OVERRIDE_;
+                //! creator method
+                static IWriteFile* createWriteFile(const io::path& fileName, bool append);
 
-		//! Returns name of file.
-		virtual const io::path& getFileName() const _IRR_OVERRIDE_;
+            private:
+                //! opens the file
+                void openFile(bool append);
 
-		//! returns if file is open
-		bool isOpen() const;
-
-		//! creator method
-		static IWriteFile* createWriteFile(const io::path& fileName, bool append);
-
-	private:
-
-		//! opens the file
-		void openFile(bool append);
-
-		io::path Filename;
-		FILE* File;
-		long FileSize;
-	};
-
-} // end namespace io
+                io::path Filename;
+                #ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+                SDL_RWops* File;
+                #else
+                FILE* File;
+                #endif
+                long FileSize;
+        };
+    } // end namespace io
 } // end namespace irr
 
 #endif
-
Index: source/Irrlicht/Irrlicht.cpp
===================================================================
--- source/Irrlicht/Irrlicht.cpp	(revision 4940)
+++ source/Irrlicht/Irrlicht.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "IrrCompileConfig.h"
 
@@ -38,6 +42,10 @@
 #include "Android/CIrrDeviceAndroid.h"
 #endif
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include "CIrrDeviceSDL2.h"
+#endif
+
 #ifdef _IRR_COMPILE_WITH_SDL_DEVICE_
 #include "CIrrDeviceSDL.h"
 #endif
@@ -75,6 +83,11 @@
 
 		IrrlichtDevice* dev = 0;
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+		if (params.DeviceType == EIDT_SDL2 || (!dev && params.DeviceType == EIDT_BEST))
+			dev = new CIrrDeviceSDL2(params);
+#endif
+
 #ifdef _IRR_COMPILE_WITH_WINDOWS_DEVICE_
 		if (params.DeviceType == EIDT_WIN32 || (!dev && params.DeviceType == EIDT_BEST))
 			dev = new CIrrDeviceWin32(params);
@@ -94,7 +107,7 @@
 		if (params.DeviceType == EIDT_X11 || (!dev && params.DeviceType == EIDT_BEST))
 			dev = new CIrrDeviceLinux(params);
 #endif
-        
+
 #ifdef _IRR_COMPILE_WITH_IPHONE_DEVICE_
 		if (params.DeviceType == EIDT_IPHONE || (!dev && params.DeviceType == EIDT_BEST))
 			dev = new CIrrDeviceIPhone(params);
Index: source/Irrlicht/os.cpp
===================================================================
--- source/Irrlicht/os.cpp	(revision 4940)
+++ source/Irrlicht/os.cpp	(working copy)
@@ -1,6 +1,10 @@
 // Copyright (C) 2002-2012 Nikolaus Gebhardt
 // This file is part of the "Irrlicht Engine".
 // For conditions of distribution and use, see copyright notice in irrlicht.h
+//
+// SDL2 upgrade
+// Jonathan Frisch
+// Sep 15, 2014
 
 #include "os.h"
 #include "irrString.h"
@@ -12,6 +16,11 @@
 	#define bswap_16(X) SDL_Swap16(X)
 	#define bswap_32(X) SDL_Swap32(X)
 	#define bswap_64(X) SDL_Swap64(X)
+#elif defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+	#include <SDL2/SDL_endian.h>
+	#define bswap_16(X) SDL_Swap16(X)
+	#define bswap_32(X) SDL_Swap32(X)
+	#define bswap_64(X) SDL_Swap64(X)
 #elif defined(_IRR_WINDOWS_API_) && defined(_MSC_VER) && (_MSC_VER > 1298)
 	#include <stdlib.h>
 	#define bswap_16(X) _byteswap_ushort(X)
@@ -134,8 +143,8 @@
 	}
 
 } // end namespace os
+} // end namespace irr
 
-
 #elif defined( _IRR_ANDROID_PLATFORM_ )
 
 // ----------------------------------------------------------------
@@ -188,7 +197,59 @@
 		return (u32)(tv.tv_sec * 1000) + (tv.tv_usec / 1000);
 	}
 } // end namespace os
+} // end namespace irr
 
+#elif defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
+
+// ----------------------------------------------------------------
+// SDL2 version
+// ----------------------------------------------------------------
+
+#include <time.h>
+#include <sys/time.h>
+#include <SDL2/SDL_log.h>
+
+namespace irr
+{
+    namespace os
+    {
+        //! prints a debuginfo string
+        void Printer::print(const c8* message, ELOG_LEVEL ll)
+        {
+            switch(ll)
+            {
+                case ELL_DEBUG:
+                    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Irrlicht://%s\n", message);
+                    break;
+                case ELL_INFORMATION:
+                    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Irrlicht://%s\n", message);
+                    break;
+                case ELL_WARNING:
+                    SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Irrlicht://%s\n", message);
+                    break;
+                case ELL_ERROR:
+                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Irrlicht://%s\n", message);
+                    break;
+                default: // ELL_NONE
+                    SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Irrlicht://%s\n", message);
+                    break;
+            }
+        }
+
+        void Timer::initTimer(bool usePerformanceTimer)
+        {
+            initVirtualTimer();
+        }
+
+        u32 Timer::getRealTime()
+        {
+            timeval tv;
+            gettimeofday(&tv, 0);
+            return (u32)(tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+        }
+    } // end namespace os
+} // end namespace irr
+
 #else
 
 // ----------------------------------------------------------------
@@ -222,9 +283,12 @@
 		return (u32)(tv.tv_sec * 1000) + (tv.tv_usec / 1000);
 	}
 } // end namespace os
+} // end namespace irr
 
 #endif // end linux / android / windows
 
+namespace irr
+{
 namespace os
 {
 	// The platform independent implementation of the printer
@@ -232,26 +296,22 @@
 
 	void Printer::log(const c8* message, ELOG_LEVEL ll)
 	{
-		if (Logger)
-			Logger->log(message, ll);
+		if(Logger) Logger->log(message, ll);
 	}
 
 	void Printer::log(const wchar_t* message, ELOG_LEVEL ll)
 	{
-		if (Logger)
-			Logger->log(message, ll);
+		if(Logger) Logger->log(message, ll);
 	}
 
 	void Printer::log(const c8* message, const c8* hint, ELOG_LEVEL ll)
 	{
-		if (Logger)
-			Logger->log(message, hint, ll);
+		if(Logger) Logger->log(message, hint, ll);
 	}
 
 	void Printer::log(const c8* message, const io::path& hint, ELOG_LEVEL ll)
 	{
-		if (Logger)
-			Logger->log(message, hint.c_str(), ll);
+		if(Logger) Logger->log(message, hint.c_str(), ll);
 	}
 
 	// our Randomizer is not really os specific, so we
@@ -264,8 +324,8 @@
 	s32 Randomizer::rand()
 	{
 		// (a*seed)%m with Schrage's method
-		seed = a * (seed%q) - r* (seed/q);
-		if (seed<0)
+		seed = a * (seed % q) - r* (seed / q);
+		if(seed < 0)
 			seed += m;
 
 		return seed;
@@ -274,7 +334,7 @@
 	//! generates a pseudo random number
 	f32 Randomizer::frand()
 	{
-		return rand()*(1.f/rMax);
+		return rand() * (1.f / rMax);
 	}
 
 	s32 Randomizer::randMax()
@@ -329,8 +389,7 @@
 	//! returns current virtual time
 	u32 Timer::getTime()
 	{
-		if (isStopped())
-			return LastVirtualTime;
+		if(isStopped()) return LastVirtualTime;
 
 		return LastVirtualTime + (u32)((StaticTime - StartRealTime) * VirtualTimerSpeed);
 	}
@@ -352,7 +411,7 @@
 	//! stops the virtual timer
 	void Timer::stopTimer()
 	{
-		if (!isStopped())
+		if(!isStopped())
 		{
 			// stop the virtual timer
 			LastVirtualTime = getTime();
@@ -366,7 +425,7 @@
 	{
 		++VirtualTimerStopCounter;
 
-		if (!isStopped())
+		if(!isStopped())
 		{
 			// restart virtual timer
 			setTime(LastVirtualTime);
@@ -379,8 +438,7 @@
 		setTime(getTime());
 
 		VirtualTimerSpeed = speed;
-		if (VirtualTimerSpeed < 0.0f)
-			VirtualTimerSpeed = 0.0f;
+		if(VirtualTimerSpeed < 0.0f) VirtualTimerSpeed = 0.0f;
 	}
 
 	//! gets the speed of the virtual timer
@@ -403,5 +461,3 @@
 
 } // end namespace os
 } // end namespace irr
-
-